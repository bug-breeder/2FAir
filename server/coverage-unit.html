
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>server: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/bug-breeder/2fair/server/cmd/server/main.go (0.0%)</option>
				
				<option value="file1">github.com/bug-breeder/2fair/server/cmd/server/runner.go (0.0%)</option>
				
				<option value="file2">github.com/bug-breeder/2fair/server/docs/docs.go (0.0%)</option>
				
				<option value="file3">github.com/bug-breeder/2fair/server/internal/adapter/api/handlers/auth.go (0.0%)</option>
				
				<option value="file4">github.com/bug-breeder/2fair/server/internal/adapter/api/handlers/health.go (0.0%)</option>
				
				<option value="file5">github.com/bug-breeder/2fair/server/internal/adapter/api/handlers/webauthn.go (0.0%)</option>
				
				<option value="file6">github.com/bug-breeder/2fair/server/internal/adapter/api/middleware/auth.go (0.0%)</option>
				
				<option value="file7">github.com/bug-breeder/2fair/server/internal/adapter/api/middleware/cors.go (0.0%)</option>
				
				<option value="file8">github.com/bug-breeder/2fair/server/internal/adapter/api/middleware/security.go (0.0%)</option>
				
				<option value="file9">github.com/bug-breeder/2fair/server/internal/adapter/api/server.go (0.0%)</option>
				
				<option value="file10">github.com/bug-breeder/2fair/server/internal/adapter/database/sqlc/backup_recovery.sql.go (0.0%)</option>
				
				<option value="file11">github.com/bug-breeder/2fair/server/internal/adapter/database/sqlc/db.go (0.0%)</option>
				
				<option value="file12">github.com/bug-breeder/2fair/server/internal/adapter/database/sqlc/device_sessions.sql.go (0.0%)</option>
				
				<option value="file13">github.com/bug-breeder/2fair/server/internal/adapter/database/sqlc/encryption_keys.sql.go (0.0%)</option>
				
				<option value="file14">github.com/bug-breeder/2fair/server/internal/adapter/database/sqlc/totp_seeds.sql.go (0.0%)</option>
				
				<option value="file15">github.com/bug-breeder/2fair/server/internal/adapter/database/sqlc/users.sql.go (0.0%)</option>
				
				<option value="file16">github.com/bug-breeder/2fair/server/internal/adapter/database/sqlc/webauthn.sql.go (0.0%)</option>
				
				<option value="file17">github.com/bug-breeder/2fair/server/internal/adapter/database/user_repository.go (0.0%)</option>
				
				<option value="file18">github.com/bug-breeder/2fair/server/internal/adapter/http/controller/auth.go (0.0%)</option>
				
				<option value="file19">github.com/bug-breeder/2fair/server/internal/adapter/http/controller/otp.go (0.0%)</option>
				
				<option value="file20">github.com/bug-breeder/2fair/server/internal/adapter/http/middleware/auth.go (0.0%)</option>
				
				<option value="file21">github.com/bug-breeder/2fair/server/internal/adapter/http/router/router.go (0.0%)</option>
				
				<option value="file22">github.com/bug-breeder/2fair/server/internal/adapter/repository/postgres/connection.go (0.0%)</option>
				
				<option value="file23">github.com/bug-breeder/2fair/server/internal/adapter/repository/postgres/generated/db.go (0.0%)</option>
				
				<option value="file24">github.com/bug-breeder/2fair/server/internal/adapter/repository/postgres/generated/login_events.sql.go (0.0%)</option>
				
				<option value="file25">github.com/bug-breeder/2fair/server/internal/adapter/repository/postgres/generated/otps.sql.go (0.0%)</option>
				
				<option value="file26">github.com/bug-breeder/2fair/server/internal/adapter/repository/postgres/generated/users.sql.go (0.0%)</option>
				
				<option value="file27">github.com/bug-breeder/2fair/server/internal/adapter/repository/postgres/login_event.go (0.0%)</option>
				
				<option value="file28">github.com/bug-breeder/2fair/server/internal/adapter/repository/postgres/otp.go (0.0%)</option>
				
				<option value="file29">github.com/bug-breeder/2fair/server/internal/adapter/repository/postgres/user.go (0.0%)</option>
				
				<option value="file30">github.com/bug-breeder/2fair/server/internal/domain/entities/device_session.go (0.0%)</option>
				
				<option value="file31">github.com/bug-breeder/2fair/server/internal/domain/entities/encryption_key.go (0.0%)</option>
				
				<option value="file32">github.com/bug-breeder/2fair/server/internal/domain/entities/totp_seed.go (0.0%)</option>
				
				<option value="file33">github.com/bug-breeder/2fair/server/internal/domain/entities/user.go (100.0%)</option>
				
				<option value="file34">github.com/bug-breeder/2fair/server/internal/domain/entities/webauthn_credential.go (100.0%)</option>
				
				<option value="file35">github.com/bug-breeder/2fair/server/internal/domain/models/otp.go (0.0%)</option>
				
				<option value="file36">github.com/bug-breeder/2fair/server/internal/infrastructure/config/config.go (0.0%)</option>
				
				<option value="file37">github.com/bug-breeder/2fair/server/internal/infrastructure/configs/configs.go (0.0%)</option>
				
				<option value="file38">github.com/bug-breeder/2fair/server/internal/infrastructure/database/migrations.go (0.0%)</option>
				
				<option value="file39">github.com/bug-breeder/2fair/server/internal/infrastructure/database/postgres.go (0.0%)</option>
				
				<option value="file40">github.com/bug-breeder/2fair/server/internal/infrastructure/jwt/token_service.go (0.0%)</option>
				
				<option value="file41">github.com/bug-breeder/2fair/server/internal/infrastructure/oauth/oauth_service.go (0.0%)</option>
				
				<option value="file42">github.com/bug-breeder/2fair/server/internal/infrastructure/services/auth_service.go (70.0%)</option>
				
				<option value="file43">github.com/bug-breeder/2fair/server/internal/infrastructure/services/webauthn_service.go (22.9%)</option>
				
				<option value="file44">github.com/bug-breeder/2fair/server/internal/test/suite.go (0.0%)</option>
				
				<option value="file45">github.com/bug-breeder/2fair/server/internal/usecase/auth/auth_service.go (0.0%)</option>
				
				<option value="file46">github.com/bug-breeder/2fair/server/internal/usecase/auth_usecase.go (0.0%)</option>
				
				<option value="file47">github.com/bug-breeder/2fair/server/internal/usecase/otp_usecase.go (0.0%)</option>
				
				<option value="file48">github.com/bug-breeder/2fair/server/internal/utils/jwt.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "context"
        "log/slog"
        "os"
        "os/signal"
        "syscall"

        "github.com/bug-breeder/2fair/server/internal/adapter/api"
        "github.com/bug-breeder/2fair/server/internal/infrastructure/config"
        "github.com/bug-breeder/2fair/server/internal/infrastructure/database"

        _ "github.com/bug-breeder/2fair/server/docs" // This is important for the Swagger docs to be generated
)

// @title 2FAir API
// @version 1.0
// @description This is the API documentation for the 2FAir E2E encrypted TOTP vault application.
// @termsOfService http://swagger.io/terms/

// @contact.name Alan Nguyen
// @contact.url http://www.2fair.vip/support
// @contact.email anhngw@gmail.com

// @license.name GNU General Public License v3.0
// @license.url https://www.gnu.org/licenses/gpl-3.0.en.html

// @host localhost:8080
// @BasePath /v1
func main() <span class="cov0" title="0">{
        // Initialize structured logging
        logger := slog.New(slog.NewJSONHandler(os.Stdout, &amp;slog.HandlerOptions{
                Level: slog.LevelInfo,
        }))
        slog.SetDefault(logger)

        // Load configuration
        cfg, err := config.Load()
        if err != nil </span><span class="cov0" title="0">{
                slog.Error("Failed to load configuration", "error", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">slog.Info("Starting 2FAir server",
                "environment", cfg.Server.Environment,
                "address", cfg.GetServerAddress(),
        )

        // Run the application
        if err := run(cfg); err != nil </span><span class="cov0" title="0">{
                slog.Error("Application failed", "error", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">slog.Info("2FAir server shutdown complete")</span>
}

func run(cfg *config.Config) error <span class="cov0" title="0">{
        // Initialize database connection
        db, err := database.NewDB(cfg)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer db.Close()

        slog.Info("Database connection established")

        // Run database migrations
        if err := database.RunMigrations(cfg); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">slog.Info("Database migrations completed")

        // Create and start HTTP server
        server := api.NewServer(cfg, db)

        // Channel to listen for interrupt/terminate signals
        stop := make(chan os.Signal, 1)
        signal.Notify(stop, os.Interrupt, syscall.SIGTERM)

        // Start server in a goroutine
        go func() </span><span class="cov0" title="0">{
                if err := server.Start(); err != nil </span><span class="cov0" title="0">{
                        slog.Error("Server failed to start", "error", err)
                        stop &lt;- syscall.SIGTERM
                }</span>
        }()

        <span class="cov0" title="0">slog.Info("Server started successfully")

        // Wait for interrupt signal
        &lt;-stop

        slog.Info("Shutting down server...")

        // Create a context with timeout for graceful shutdown
        ctx, cancel := context.WithTimeout(context.Background(), cfg.Server.ShutdownTimeout)
        defer cancel()

        // Attempt graceful shutdown
        if err := server.Stop(ctx); err != nil </span><span class="cov0" title="0">{
                slog.Error("Server forced to shutdown", "error", err)
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "log"

        _ "github.com/bug-breeder/2fair/server/docs" // This is important for the Swagger docs to be generated
        "github.com/bug-breeder/2fair/server/internal/adapter/http/controller"
        route "github.com/bug-breeder/2fair/server/internal/adapter/http/router"
        "github.com/bug-breeder/2fair/server/internal/adapter/repository/postgres" // Updated to postgres package
        "github.com/bug-breeder/2fair/server/internal/infrastructure/configs"
        "github.com/bug-breeder/2fair/server/internal/usecase"
        "github.com/gin-contrib/cors"
        "github.com/gin-gonic/gin"
)

func runServer() <span class="cov0" title="0">{
        // Setup router
        router := gin.Default()
        // CORS configuration
        router.Use(cors.New(cors.Config{
                AllowOrigins:     []string{"https://2fair.vip", "http://localhost:3000", "http://localhost:5173", "http://localhost:5174", "https://app.2fair.vip"},
                AllowMethods:     []string{"GET", "POST", "PUT", "DELETE", "OPTIONS"},
                AllowHeaders:     []string{"Origin", "Authorization", "Content-Type"},
                ExposeHeaders:    []string{"Content-Length"},
                AllowCredentials: true,
        }))

        router.Use(gin.Logger())
        router.Use(gin.Recovery())

        // Setup database connection
        db, err := postgres.NewPostgresConnection(
                configs.GetEnv("DB_HOST"),
                configs.GetEnv("DB_PORT"),
                configs.GetEnv("DB_USER"),
                configs.GetEnv("DB_PASSWORD"),
                configs.GetEnv("DB_NAME"),
                configs.GetEnv("DB_SSL_MODE"),
        )
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to connect to database: %v", err)
        }</span>
        <span class="cov0" title="0">log.Printf("Successfully connected to database at %s:%s", configs.GetEnv("DB_HOST"), configs.GetEnv("DB_PORT"))

        // Setup repositories with PostgreSQL
        userRepo := postgres.NewPostgresUserRepository(db)
        otpRepo := postgres.NewPostgresOTPRepository(db)
        loginEventRepo := postgres.NewPostgresLoginEventRepository(db)

        // Setup use cases
        authUseCase := usecase.NewAuthUseCase(userRepo, loginEventRepo)
        otpUseCase := usecase.NewOTPUseCase(otpRepo)

        // Setup controllers
        authController := controller.NewAuthController(authUseCase)
        otpController := controller.NewOTPController(otpUseCase)

        // Setup routes
        route.SetupRoutes(router, authController, otpController)

        log.Printf("Server starting on :8080")
        if err := router.Run(); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to run server: %v", err)
        }</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">// Package docs Code generated by swaggo/swag. DO NOT EDIT
package docs

import "github.com/swaggo/swag"

const docTemplate = `{
    "schemes": {{ marshal .Schemes }},
    "swagger": "2.0",
    "info": {
        "description": "{{escape .Description}}",
        "title": "{{.Title}}",
        "termsOfService": "http://swagger.io/terms/",
        "contact": {
            "name": "Alan Nguyen",
            "url": "http://www.2fair.vip/support",
            "email": "anhngw@gmail.com"
        },
        "license": {
            "name": "GNU General Public License v3.0",
            "url": "https://www.gnu.org/licenses/gpl-3.0.en.html"
        },
        "version": "{{.Version}}"
    },
    "host": "{{.Host}}",
    "basePath": "{{.BasePath}}",
    "paths": {
        "/api/v1/auth/google": {
            "get": {
                "description": "Authenticate a user using Google OAuth",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "auth"
                ],
                "summary": "Login with Google",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/models.User"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    }
                }
            }
        },
        "/api/v1/auth/google/callback": {
            "get": {
                "description": "Handle the callback from Google OAuth",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "auth"
                ],
                "summary": "Google OAuth callback",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    }
                }
            }
        },
        "/api/v1/auth/logout": {
            "post": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "Log out the current user",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "auth"
                ],
                "summary": "Logout",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    }
                }
            }
        },
        "/api/v1/auth/me": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "Get the currently authenticated user's information",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "auth"
                ],
                "summary": "Get current user",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/models.User"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    }
                }
            }
        },
        "/api/v1/auth/refresh": {
            "post": {
                "description": "Refresh the access token using the refresh token cookie",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "auth"
                ],
                "summary": "Refresh access token",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/dto.MessageResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/dto.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/dto.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/api/v1/login-history": {
            "get": {
                "description": "Get the login history for the authenticated user",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "auth"
                ],
                "summary": "Get login history",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/models.LoginEvent"
                            }
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/dto.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/dto.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/api/v1/otp": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "Get all OTPs for the authenticated user",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "otp"
                ],
                "summary": "List OTPs",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/models.OTP"
                            }
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    }
                }
            },
            "post": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "Add a new OTP for the authenticated user",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "otp"
                ],
                "summary": "Add OTP",
                "parameters": [
                    {
                        "description": "OTP details",
                        "name": "otp",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/models.OTP"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    }
                }
            }
        },
        "/api/v1/otp/codes": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "Generate current and next OTP codes for the user",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "otp"
                ],
                "summary": "Generate OTP codes",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/dto.GenerateOTPCodesResponse"
                            }
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/dto.ErrorResponse"
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/dto.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/dto.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/api/v1/otp/{id}": {
            "put": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "Edit an existing OTP",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "otp"
                ],
                "summary": "Edit OTP",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "OTP ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "Updated OTP details",
                        "name": "otp",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/models.OTP"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    }
                }
            }
        },
        "/api/v1/otp/{id}/inactivate": {
            "post": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "Mark an OTP as inactive",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "otp"
                ],
                "summary": "Inactivate OTP",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "OTP ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    }
                }
            }
        }
    },
    "definitions": {
        "dto.ErrorResponse": {
            "type": "object",
            "properties": {
                "error": {
                    "type": "string"
                }
            }
        },
        "dto.GenerateOTPCodesResponse": {
            "type": "object",
            "properties": {
                "CurrentCode": {
                    "type": "string"
                },
                "CurrentExpireAt": {
                    "type": "string"
                },
                "Id": {
                    "type": "integer"
                },
                "NextCode": {
                    "type": "string"
                },
                "NextExpireAt": {
                    "type": "string"
                }
            }
        },
        "dto.MessageResponse": {
            "type": "object",
            "properties": {
                "message": {
                    "type": "string"
                }
            }
        },
        "models.LoginEvent": {
            "type": "object",
            "properties": {
                "id": {
                    "type": "integer"
                },
                "ip_address": {
                    "type": "string"
                },
                "timestamp": {
                    "type": "string"
                },
                "user_agent": {
                    "type": "string"
                },
                "user_id": {
                    "type": "integer"
                }
            }
        },
        "models.OTP": {
            "type": "object",
            "properties": {
                "active": {
                    "type": "boolean"
                },
                "algorithm": {
                    "type": "string"
                },
                "counter": {
                    "type": "integer"
                },
                "created_at": {
                    "type": "string"
                },
                "digits": {
                    "type": "integer"
                },
                "id": {
                    "type": "integer"
                },
                "issuer": {
                    "type": "string"
                },
                "label": {
                    "type": "string"
                },
                "method": {
                    "type": "string"
                },
                "period": {
                    "type": "integer"
                },
                "secret": {
                    "type": "string"
                },
                "user_id": {
                    "type": "integer"
                }
            }
        },
        "models.User": {
            "type": "object",
            "properties": {
                "created_at": {
                    "type": "string"
                },
                "email": {
                    "type": "string"
                },
                "id": {
                    "type": "integer"
                },
                "name": {
                    "type": "string"
                },
                "provider": {
                    "type": "string"
                },
                "provider_id": {
                    "type": "string"
                }
            }
        }
    }
}`

// SwaggerInfo holds exported Swagger Info so clients can modify it
var SwaggerInfo = &amp;swag.Spec{
        Version:          "1.0",
        Host:             "localhost:8080",
        BasePath:         "/",
        Schemes:          []string{},
        Title:            "2FAir API",
        Description:      "This is the API documentation for the 2FAir application.",
        InfoInstanceName: "swagger",
        SwaggerTemplate:  docTemplate,
        LeftDelim:        "{{",
        RightDelim:       "}}",
}

func init() <span class="cov0" title="0">{
        swag.Register(SwaggerInfo.InstanceName(), SwaggerInfo)
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package handlers

import (
        "fmt"
        "net/http"
        "time"

        "github.com/bug-breeder/2fair/server/internal/domain/services"
        "github.com/gin-gonic/gin"
        "github.com/markbates/goth/gothic"
)

// AuthHandler handles authentication endpoints
type AuthHandler struct {
        authService services.AuthService
}

// NewAuthHandler creates a new auth handler
func NewAuthHandler(authService services.AuthService) *AuthHandler <span class="cov0" title="0">{
        return &amp;AuthHandler{
                authService: authService,
        }
}</span>

// OAuthLogin initiates OAuth login flow
// @Summary Start OAuth login
// @Description Initiates OAuth login flow with the specified provider
// @Tags auth
// @Param provider path string true "OAuth provider (google, github)"
// @Success 302 {object} map[string]string
// @Failure 400 {object} map[string]string
// @Router /auth/{provider} [get]
func (h *AuthHandler) OAuthLogin(c *gin.Context) <span class="cov0" title="0">{
        provider := c.Param("provider")

        // Validate provider
        if provider != "google" &amp;&amp; provider != "github" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "unsupported provider"})
                return
        }</span>

        // Set provider in query params for gothic
        <span class="cov0" title="0">q := c.Request.URL.Query()
        q.Add("provider", provider)
        c.Request.URL.RawQuery = q.Encode()

        // Start OAuth flow
        gothic.BeginAuthHandler(c.Writer, c.Request)</span>
}

// OAuthCallback handles OAuth callback
// @Summary Handle OAuth callback
// @Description Handles OAuth callback from provider
// @Tags auth
// @Param provider path string true "OAuth provider (google, github)"
// @Param code query string true "OAuth authorization code"
// @Param state query string true "OAuth state parameter"
// @Success 200 {object} map[string]interface{}
// @Failure 400 {object} map[string]string
// @Failure 500 {object} map[string]string
// @Router /auth/{provider}/callback [get]
func (h *AuthHandler) OAuthCallback(c *gin.Context) <span class="cov0" title="0">{
        provider := c.Param("provider")

        // Set provider in query params for gothic
        q := c.Request.URL.Query()
        q.Add("provider", provider)
        c.Request.URL.RawQuery = q.Encode()

        // Complete OAuth flow
        gothUser, err := gothic.CompleteUserAuth(c.Writer, c.Request)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "OAuth authentication failed"})
                return
        }</span>

        // Convert to our OAuth provider format
        <span class="cov0" title="0">oauthData := &amp;services.OAuthProvider{
                Provider:    provider,
                UserID:      gothUser.UserID,
                Email:       gothUser.Email,
                Username:    gothUser.NickName,
                DisplayName: gothUser.Name,
                AvatarURL:   gothUser.AvatarURL,
        }

        // Register or login user
        user, err := h.authService.RegisterOrLoginUser(c.Request.Context(), oauthData)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to register/login user"})
                return
        }</span>

        // Generate JWT token
        <span class="cov0" title="0">token, err := h.authService.GenerateJWT(user)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to generate token"})
                return
        }</span>

        // Set token in cookie
        <span class="cov0" title="0">c.SetCookie(
                "auth_token",
                token,
                int(24*time.Hour.Seconds()), // 24 hours
                "/",
                "",
                false, // not HTTPS-only for development
                true,  // HTTP-only
        )

        // Return success response
        c.JSON(http.StatusOK, gin.H{
                "message": "authentication successful",
                "user": gin.H{
                        "id":          user.ID,
                        "username":    user.Username,
                        "email":       user.Email,
                        "displayName": user.DisplayName,
                },
                "token": token,
        })</span>
}

// Logout handles user logout
// @Summary Logout user
// @Description Logs out the current user
// @Tags auth
// @Success 200 {object} map[string]string
// @Router /auth/logout [post]
func (h *AuthHandler) Logout(c *gin.Context) <span class="cov0" title="0">{
        // Clear auth cookie
        c.SetCookie(
                "auth_token",
                "",
                -1,
                "/",
                "",
                false,
                true,
        )

        c.JSON(http.StatusOK, gin.H{"message": "logged out successfully"})
}</span>

// RefreshToken refreshes the JWT token
// @Summary Refresh JWT token
// @Description Refreshes the JWT token if it's close to expiry
// @Tags auth
// @Success 200 {object} map[string]interface{}
// @Failure 401 {object} map[string]string
// @Failure 500 {object} map[string]string
// @Router /auth/refresh [post]
func (h *AuthHandler) RefreshToken(c *gin.Context) <span class="cov0" title="0">{
        // Get token from cookie or header
        token, err := c.Cookie("auth_token")
        if err != nil </span><span class="cov0" title="0">{
                // Try Authorization header
                authHeader := c.GetHeader("Authorization")
                if authHeader == "" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusUnauthorized, gin.H{"error": "no token provided"})
                        return
                }</span>

                // Extract token from "Bearer &lt;token&gt;"
                <span class="cov0" title="0">if len(authHeader) &gt; 7 &amp;&amp; authHeader[:7] == "Bearer " </span><span class="cov0" title="0">{
                        token = authHeader[7:]
                }</span> else<span class="cov0" title="0"> {
                        c.JSON(http.StatusUnauthorized, gin.H{"error": "invalid token format"})
                        return
                }</span>
        }

        // Refresh token
        <span class="cov0" title="0">newToken, err := h.authService.RefreshJWT(token)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "failed to refresh token"})
                return
        }</span>

        // Set new token in cookie
        <span class="cov0" title="0">c.SetCookie(
                "auth_token",
                newToken,
                int(24*time.Hour.Seconds()),
                "/",
                "",
                false,
                true,
        )

        c.JSON(http.StatusOK, gin.H{
                "message": "token refreshed successfully",
                "token":   newToken,
        })</span>
}

// GetProfile returns the current user's profile
// @Summary Get user profile
// @Description Returns the current authenticated user's profile
// @Tags auth
// @Security BearerAuth
// @Success 200 {object} map[string]interface{}
// @Failure 401 {object} map[string]string
// @Router /auth/profile [get]
func (h *AuthHandler) GetProfile(c *gin.Context) <span class="cov0" title="0">{
        // Get user from context (set by auth middleware)
        userInterface, exists := c.Get("user")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "user not found in context"})
                return
        }</span>

        <span class="cov0" title="0">claims, ok := userInterface.(*services.JWTClaims)
        if !ok </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "invalid user context"})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "user": gin.H{
                        "id":       claims.UserID,
                        "username": claims.Username,
                        "email":    claims.Email,
                },
        })</span>
}

// GetProviders returns available OAuth providers
// @Summary Get OAuth providers
// @Description Returns list of available OAuth providers
// @Tags auth
// @Success 200 {object} map[string]interface{}
// @Router /auth/providers [get]
func (h *AuthHandler) GetProviders(c *gin.Context) <span class="cov0" title="0">{
        providers := []map[string]string{
                {
                        "name":        "Google",
                        "provider":    "google",
                        "login_url":   fmt.Sprintf("%s/auth/google", c.Request.Host),
                        "description": "Sign in with Google",
                },
                {
                        "name":        "GitHub",
                        "provider":    "github",
                        "login_url":   fmt.Sprintf("%s/auth/github", c.Request.Host),
                        "description": "Sign in with GitHub",
                },
        }

        c.JSON(http.StatusOK, gin.H{
                "providers": providers,
        })
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package handlers

import (
        "net/http"

        "github.com/bug-breeder/2fair/server/internal/infrastructure/database"
        "github.com/gin-gonic/gin"
)

// HealthHandler handles health check endpoints
type HealthHandler struct {
        db *database.DB
}

// NewHealthHandler creates a new health handler
func NewHealthHandler(db *database.DB) *HealthHandler <span class="cov0" title="0">{
        return &amp;HealthHandler{db: db}
}</span>

// Health returns the overall health status
func (h *HealthHandler) Health(c *gin.Context) <span class="cov0" title="0">{
        c.JSON(http.StatusOK, gin.H{"status": "healthy"})
}</span>

// Ready returns readiness status
func (h *HealthHandler) Ready(c *gin.Context) <span class="cov0" title="0">{
        c.JSON(http.StatusOK, gin.H{"status": "ready"})
}</span>

// Live returns liveness status
func (h *HealthHandler) Live(c *gin.Context) <span class="cov0" title="0">{
        c.JSON(http.StatusOK, gin.H{"status": "alive"})
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package handlers

import (
        "net/http"

        "github.com/bug-breeder/2fair/server/internal/adapter/api/middleware"
        "github.com/bug-breeder/2fair/server/internal/domain/entities"
        "github.com/bug-breeder/2fair/server/internal/domain/services"
        "github.com/gin-gonic/gin"
        "github.com/go-webauthn/webauthn/protocol"
        "github.com/go-webauthn/webauthn/webauthn"
        "github.com/google/uuid"
)

// WebAuthnHandler handles WebAuthn endpoints
type WebAuthnHandler struct {
        webAuthnService services.WebAuthnService
        userRepo        services.AuthService // Use auth service to get user info
}

// NewWebAuthnHandler creates a new WebAuthn handler
func NewWebAuthnHandler(webAuthnService services.WebAuthnService, authService services.AuthService) *WebAuthnHandler <span class="cov0" title="0">{
        return &amp;WebAuthnHandler{
                webAuthnService: webAuthnService,
                userRepo:        authService,
        }
}</span>

// SessionStore temporarily stores WebAuthn session data
// TODO: In production, use Redis or database for session storage
var sessionStore = make(map[string]*webauthn.SessionData)

// BeginRegistration starts WebAuthn credential registration
// @Summary Start WebAuthn credential registration
// @Description Begins WebAuthn credential registration for vault encryption
// @Tags webauthn
// @Security BearerAuth
// @Param authenticatorSelection body protocol.AuthenticatorSelection false "Authenticator selection criteria"
// @Success 200 {object} services.WebAuthnCredentialCreation
// @Failure 401 {object} map[string]string
// @Failure 500 {object} map[string]string
// @Router /v1/webauthn/register/begin [post]
func (h *WebAuthnHandler) BeginRegistration(c *gin.Context) <span class="cov0" title="0">{
        // Get current user from JWT claims
        claims, exists := middleware.GetCurrentUser(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "user not found in context"})
                return
        }</span>

        // Parse authenticator selection if provided
        <span class="cov0" title="0">var authenticatorSelection *protocol.AuthenticatorSelection
        if c.Request.ContentLength &gt; 0 </span><span class="cov0" title="0">{
                if err := c.ShouldBindJSON(&amp;authenticatorSelection); err != nil </span><span class="cov0" title="0">{
                        // If binding fails, continue with nil (use defaults)
                        authenticatorSelection = nil
                }</span>
        }

        // Create user entity from claims
        <span class="cov0" title="0">userID, err := uuid.Parse(claims.UserID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "invalid user ID"})
                return
        }</span>

        <span class="cov0" title="0">user := &amp;entities.User{
                ID:          userID,
                Username:    claims.Username,
                Email:       claims.Email,
                DisplayName: claims.Username, // Use username as display name for now
        }

        // Begin registration
        credentialCreation, err := h.webAuthnService.BeginRegistration(c.Request.Context(), user, authenticatorSelection)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to begin registration"})
                return
        }</span>

        // Store session data (in production, use proper session storage)
        <span class="cov0" title="0">sessionKey := claims.UserID + "_registration"
        sessionStore[sessionKey] = credentialCreation.SessionData

        // Return only the public credential creation options
        c.JSON(http.StatusOK, gin.H{
                "publicKey": credentialCreation.PublicKeyCredentialCreationOptions,
        })</span>
}

// FinishRegistration completes WebAuthn credential registration
// @Summary Complete WebAuthn credential registration
// @Description Completes WebAuthn credential registration for vault encryption
// @Tags webauthn
// @Security BearerAuth
// @Success 200 {object} map[string]interface{}
// @Failure 401 {object} map[string]string
// @Failure 400 {object} map[string]string
// @Failure 500 {object} map[string]string
// @Router /v1/webauthn/register/finish [post]
func (h *WebAuthnHandler) FinishRegistration(c *gin.Context) <span class="cov0" title="0">{
        // Get current user from JWT claims
        claims, exists := middleware.GetCurrentUser(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "user not found in context"})
                return
        }</span>

        // Get stored session data
        <span class="cov0" title="0">sessionKey := claims.UserID + "_registration"
        sessionData, exists := sessionStore[sessionKey]
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "no registration session found"})
                return
        }</span>

        // Create user entity from claims
        <span class="cov0" title="0">userID, err := uuid.Parse(claims.UserID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "invalid user ID"})
                return
        }</span>

        <span class="cov0" title="0">user := &amp;entities.User{
                ID:          userID,
                Username:    claims.Username,
                Email:       claims.Email,
                DisplayName: claims.Username,
        }

        // Finish registration using the HTTP request directly
        credential, err := h.webAuthnService.FinishRegistration(c.Request.Context(), user, sessionData, c.Request)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "failed to complete registration"})
                return
        }</span>

        // Clean up session data
        <span class="cov0" title="0">delete(sessionStore, sessionKey)

        c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "WebAuthn credential registered successfully",
                "credential": gin.H{
                        "id":             credential.ID,
                        "credentialId":   credential.CredentialID,
                        "createdAt":      credential.CreatedAt,
                        "backupEligible": credential.BackupEligible,
                        "backupState":    credential.BackupState,
                },
        })</span>
}

// BeginAssertion starts WebAuthn credential assertion
// @Summary Start WebAuthn credential assertion
// @Description Begins WebAuthn credential assertion for vault key derivation
// @Tags webauthn
// @Security BearerAuth
// @Success 200 {object} services.WebAuthnCredentialAssertion
// @Failure 401 {object} map[string]string
// @Failure 500 {object} map[string]string
// @Router /v1/webauthn/assert/begin [post]
func (h *WebAuthnHandler) BeginAssertion(c *gin.Context) <span class="cov0" title="0">{
        // Get current user from JWT claims
        claims, exists := middleware.GetCurrentUser(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "user not found in context"})
                return
        }</span>

        // Create user entity from claims
        <span class="cov0" title="0">userID, err := uuid.Parse(claims.UserID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "invalid user ID"})
                return
        }</span>

        <span class="cov0" title="0">user := &amp;entities.User{
                ID:          userID,
                Username:    claims.Username,
                Email:       claims.Email,
                DisplayName: claims.Username,
        }

        // Begin assertion
        credentialAssertion, err := h.webAuthnService.BeginAssertion(c.Request.Context(), user, nil)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to begin assertion"})
                return
        }</span>

        // Store session data
        <span class="cov0" title="0">sessionKey := claims.UserID + "_assertion"
        sessionStore[sessionKey] = credentialAssertion.SessionData

        // Return only the public credential request options
        c.JSON(http.StatusOK, gin.H{
                "publicKey": credentialAssertion.PublicKeyCredentialRequestOptions,
        })</span>
}

// FinishAssertion completes WebAuthn credential assertion
// @Summary Complete WebAuthn credential assertion
// @Description Completes WebAuthn credential assertion and returns derived key material
// @Tags webauthn
// @Security BearerAuth
// @Success 200 {object} map[string]interface{}
// @Failure 401 {object} map[string]string
// @Failure 400 {object} map[string]string
// @Failure 500 {object} map[string]string
// @Router /v1/webauthn/assert/finish [post]
func (h *WebAuthnHandler) FinishAssertion(c *gin.Context) <span class="cov0" title="0">{
        // Get current user from JWT claims
        claims, exists := middleware.GetCurrentUser(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "user not found in context"})
                return
        }</span>

        // Get stored session data
        <span class="cov0" title="0">sessionKey := claims.UserID + "_assertion"
        sessionData, exists := sessionStore[sessionKey]
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "no assertion session found"})
                return
        }</span>

        // Create user entity from claims
        <span class="cov0" title="0">userID, err := uuid.Parse(claims.UserID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "invalid user ID"})
                return
        }</span>

        <span class="cov0" title="0">user := &amp;entities.User{
                ID:          userID,
                Username:    claims.Username,
                Email:       claims.Email,
                DisplayName: claims.Username,
        }

        // Finish assertion using the HTTP request directly
        credential, prfOutput, err := h.webAuthnService.FinishAssertion(c.Request.Context(), user, sessionData, c.Request)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "failed to complete assertion"})
                return
        }</span>

        // Clean up session data
        <span class="cov0" title="0">delete(sessionStore, sessionKey)

        response := gin.H{
                "success": true,
                "message": "WebAuthn assertion completed successfully",
                "credential": gin.H{
                        "id":           credential.ID,
                        "credentialId": credential.CredentialID,
                        "lastUsedAt":   credential.LastUsedAt,
                        "signCount":    credential.SignCount,
                },
        }

        // Include PRF output if available (for vault key derivation)
        if len(prfOutput) &gt; 0 </span><span class="cov0" title="0">{
                response["prfOutput"] = prfOutput
                response["message"] = "WebAuthn assertion completed with PRF key derivation"
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, response)</span>
}

// GetCredentials returns user's WebAuthn credentials
// @Summary Get user WebAuthn credentials
// @Description Returns all WebAuthn credentials for the current user
// @Tags webauthn
// @Security BearerAuth
// @Success 200 {object} map[string]interface{}
// @Failure 401 {object} map[string]string
// @Failure 500 {object} map[string]string
// @Router /v1/webauthn/credentials [get]
func (h *WebAuthnHandler) GetCredentials(c *gin.Context) <span class="cov0" title="0">{
        // Get current user from JWT claims
        claims, exists := middleware.GetCurrentUser(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "user not found in context"})
                return
        }</span>

        // Get user credentials
        <span class="cov0" title="0">credentials, err := h.webAuthnService.GetUserCredentials(c.Request.Context(), claims.UserID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to get credentials"})
                return
        }</span>

        // Return credentials without sensitive data
        <span class="cov0" title="0">credentialSummaries := make([]gin.H, len(credentials))
        for i, cred := range credentials </span><span class="cov0" title="0">{
                credentialSummaries[i] = gin.H{
                        "id":             cred.ID,
                        "createdAt":      cred.CreatedAt,
                        "lastUsedAt":     cred.LastUsedAt,
                        "transport":      cred.Transport,
                        "attachment":     cred.Attachment,
                        "backupEligible": cred.BackupEligible,
                        "backupState":    cred.BackupState,
                        "signCount":      cred.SignCount,
                }
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "credentials": credentialSummaries,
                "count":       len(credentials),
        })</span>
}

// DeleteCredential deletes a WebAuthn credential
// @Summary Delete WebAuthn credential
// @Description Deletes a specific WebAuthn credential for the current user
// @Tags webauthn
// @Security BearerAuth
// @Param credentialId path string true "Credential ID"
// @Success 200 {object} map[string]string
// @Failure 401 {object} map[string]string
// @Failure 400 {object} map[string]string
// @Failure 500 {object} map[string]string
// @Router /v1/webauthn/credentials/{credentialId} [delete]
func (h *WebAuthnHandler) DeleteCredential(c *gin.Context) <span class="cov0" title="0">{
        // Get current user from JWT claims
        claims, exists := middleware.GetCurrentUser(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "user not found in context"})
                return
        }</span>

        <span class="cov0" title="0">credentialID := c.Param("credentialId")
        if credentialID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "credential ID is required"})
                return
        }</span>

        // Delete credential
        <span class="cov0" title="0">err := h.webAuthnService.DeleteCredential(c.Request.Context(), claims.UserID, []byte(credentialID))
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to delete credential"})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "message": "WebAuthn credential deleted successfully",
        })</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package middleware

import (
        "net/http"
        "strings"

        "github.com/bug-breeder/2fair/server/internal/domain/services"
        "github.com/gin-gonic/gin"
)

// AuthMiddleware provides JWT authentication middleware
type AuthMiddleware struct {
        authService services.AuthService
}

// NewAuthMiddleware creates a new auth middleware
func NewAuthMiddleware(authService services.AuthService) *AuthMiddleware <span class="cov0" title="0">{
        return &amp;AuthMiddleware{
                authService: authService,
        }
}</span>

// RequireAuth middleware that requires authentication
func (m *AuthMiddleware) RequireAuth() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                token := m.extractToken(c)
                if token == "" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusUnauthorized, gin.H{"error": "authentication required"})
                        c.Abort()
                        return
                }</span>

                // Validate token
                <span class="cov0" title="0">claims, err := m.authService.ValidateJWT(token)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusUnauthorized, gin.H{"error": "invalid token"})
                        c.Abort()
                        return
                }</span>

                // Set user in context
                <span class="cov0" title="0">c.Set("user", claims)
                c.Set("user_id", claims.UserID)
                c.Set("username", claims.Username)
                c.Set("email", claims.Email)

                c.Next()</span>
        }
}

// OptionalAuth middleware that optionally checks authentication
func (m *AuthMiddleware) OptionalAuth() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                token := m.extractToken(c)
                if token == "" </span><span class="cov0" title="0">{
                        // No token provided, continue without authentication
                        c.Next()
                        return
                }</span>

                // Validate token if provided
                <span class="cov0" title="0">claims, err := m.authService.ValidateJWT(token)
                if err != nil </span><span class="cov0" title="0">{
                        // Invalid token, continue without authentication
                        c.Next()
                        return
                }</span>

                // Set user in context
                <span class="cov0" title="0">c.Set("user", claims)
                c.Set("user_id", claims.UserID)
                c.Set("username", claims.Username)
                c.Set("email", claims.Email)

                c.Next()</span>
        }
}

// extractToken extracts JWT token from request
func (m *AuthMiddleware) extractToken(c *gin.Context) string <span class="cov0" title="0">{
        // Try to get token from Authorization header
        authHeader := c.GetHeader("Authorization")
        if authHeader != "" </span><span class="cov0" title="0">{
                // Extract token from "Bearer &lt;token&gt;"
                if len(authHeader) &gt; 7 &amp;&amp; strings.ToLower(authHeader[:7]) == "bearer " </span><span class="cov0" title="0">{
                        return authHeader[7:]
                }</span>
        }

        // Try to get token from cookie
        <span class="cov0" title="0">token, err := c.Cookie("auth_token")
        if err == nil </span><span class="cov0" title="0">{
                return token
        }</span>

        // Try to get token from query parameter (less secure, for testing)
        <span class="cov0" title="0">if queryToken := c.Query("token"); queryToken != "" </span><span class="cov0" title="0">{
                return queryToken
        }</span>

        <span class="cov0" title="0">return ""</span>
}

// GetCurrentUser helper function to get current user from context
func GetCurrentUser(c *gin.Context) (*services.JWTClaims, bool) <span class="cov0" title="0">{
        userInterface, exists := c.Get("user")
        if !exists </span><span class="cov0" title="0">{
                return nil, false
        }</span>

        <span class="cov0" title="0">claims, ok := userInterface.(*services.JWTClaims)
        if !ok </span><span class="cov0" title="0">{
                return nil, false
        }</span>

        <span class="cov0" title="0">return claims, true</span>
}

// GetCurrentUserID helper function to get current user ID from context
func GetCurrentUserID(c *gin.Context) (string, bool) <span class="cov0" title="0">{
        userID, exists := c.Get("user_id")
        if !exists </span><span class="cov0" title="0">{
                return "", false
        }</span>

        <span class="cov0" title="0">userIDStr, ok := userID.(string)
        if !ok </span><span class="cov0" title="0">{
                return "", false
        }</span>

        <span class="cov0" title="0">return userIDStr, true</span>
}

// RequireAdmin middleware that requires admin authentication (placeholder)
func (m *AuthMiddleware) RequireAdmin() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                // First check if user is authenticated
                token := m.extractToken(c)
                if token == "" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusUnauthorized, gin.H{"error": "authentication required"})
                        c.Abort()
                        return
                }</span>

                // Validate token
                <span class="cov0" title="0">claims, err := m.authService.ValidateJWT(token)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusUnauthorized, gin.H{"error": "invalid token"})
                        c.Abort()
                        return
                }</span>

                // TODO: Add admin role checking logic here
                // For now, just check if user is authenticated

                // Set user in context
                <span class="cov0" title="0">c.Set("user", claims)
                c.Set("user_id", claims.UserID)
                c.Set("username", claims.Username)
                c.Set("email", claims.Email)

                c.Next()</span>
        }
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package middleware

import (
        "time"

        "github.com/gin-contrib/cors"
        "github.com/gin-gonic/gin"

        "github.com/bug-breeder/2fair/server/internal/infrastructure/config"
)

// CORS creates a CORS middleware with the given configuration
func CORS(cfg *config.Config) gin.HandlerFunc <span class="cov0" title="0">{
        corsConfig := cors.Config{
                AllowOrigins:     cfg.Security.CORSOrigins,
                AllowMethods:     []string{"GET", "POST", "PUT", "DELETE", "OPTIONS"},
                AllowHeaders:     []string{"Accept", "Authorization", "Content-Type", "X-CSRF-Token", "X-Device-ID"},
                ExposeHeaders:    []string{"X-Request-ID", "X-Rate-Limit-Remaining", "X-Rate-Limit-Reset"},
                AllowCredentials: true,
                MaxAge:           12 * time.Hour,
        }

        // In development, allow all origins
        if cfg.IsDevelopment() </span><span class="cov0" title="0">{
                corsConfig.AllowAllOrigins = true
                corsConfig.AllowOrigins = nil
        }</span>

        <span class="cov0" title="0">return cors.New(corsConfig)</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package middleware

import (
        "github.com/gin-gonic/gin"

        "github.com/bug-breeder/2fair/server/internal/infrastructure/config"
)

// Security adds security headers to all responses
func Security(cfg *config.Config) gin.HandlerFunc <span class="cov0" title="0">{
        return gin.HandlerFunc(func(c *gin.Context) </span><span class="cov0" title="0">{
                // Content Security Policy
                c.Header("Content-Security-Policy", cfg.Security.CSPPolicy)

                // Prevent MIME type sniffing
                c.Header("X-Content-Type-Options", "nosniff")

                // Prevent clickjacking
                c.Header("X-Frame-Options", "DENY")

                // XSS Protection
                c.Header("X-XSS-Protection", "1; mode=block")

                // HTTP Strict Transport Security (HSTS)
                if cfg.IsProduction() </span><span class="cov0" title="0">{
                        c.Header("Strict-Transport-Security", "max-age=31536000; includeSubDomains; preload")
                }</span>

                // Referrer Policy
                <span class="cov0" title="0">c.Header("Referrer-Policy", "strict-origin-when-cross-origin")

                // Permissions Policy (Feature Policy)
                c.Header("Permissions-Policy", "camera=(), microphone=(), geolocation=(), payment=()")

                // Cross-Origin Embedder Policy
                c.Header("Cross-Origin-Embedder-Policy", "require-corp")

                // Cross-Origin Opener Policy
                c.Header("Cross-Origin-Opener-Policy", "same-origin")

                // Cross-Origin Resource Policy
                c.Header("Cross-Origin-Resource-Policy", "same-origin")

                // Cache Control for security-sensitive endpoints
                if c.Request.URL.Path == "/auth" || c.Request.URL.Path == "/vault" </span><span class="cov0" title="0">{
                        c.Header("Cache-Control", "no-cache, no-store, must-revalidate")
                        c.Header("Pragma", "no-cache")
                        c.Header("Expires", "0")
                }</span>

                <span class="cov0" title="0">c.Next()</span>
        })
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package api

import (
        "context"
        "fmt"
        "log/slog"
        "net/http"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/markbates/goth"
        "github.com/markbates/goth/providers/github"
        "github.com/markbates/goth/providers/google"

        "github.com/bug-breeder/2fair/server/internal/adapter/api/handlers"
        "github.com/bug-breeder/2fair/server/internal/adapter/api/middleware"
        database_adapters "github.com/bug-breeder/2fair/server/internal/adapter/database"
        "github.com/bug-breeder/2fair/server/internal/infrastructure/config"
        "github.com/bug-breeder/2fair/server/internal/infrastructure/database"
        "github.com/bug-breeder/2fair/server/internal/infrastructure/services"
)

// Server represents the HTTP server
type Server struct {
        httpServer *http.Server
        config     *config.Config
        db         *database.DB
}

// NewServer creates a new HTTP server
func NewServer(cfg *config.Config, db *database.DB) *Server <span class="cov0" title="0">{
        // Set Gin mode based on environment
        if cfg.IsProduction() </span><span class="cov0" title="0">{
                gin.SetMode(gin.ReleaseMode)
        }</span>

        // Configure OAuth providers
        <span class="cov0" title="0">configureOAuthProviders(cfg)

        // Create Gin router
        router := gin.New()

        // Add global middleware
        router.Use(gin.Recovery())
        router.Use(middleware.CORS(cfg))
        router.Use(middleware.Security(cfg))

        // Add custom middleware for request ID, logging, etc.
        router.Use(RequestID())
        router.Use(Logger())

        // Initialize repositories
        userRepo := database_adapters.NewUserRepository(db)
        // TODO: Implement WebAuthn credential repository properly
        // credRepo := database_adapters.NewWebAuthnCredentialRepository(db)

        // Initialize services
        authService := services.NewAuthService(
                userRepo,
                cfg.JWT.SigningKey,
                cfg.JWT.ExpirationTime,
                fmt.Sprintf("http://%s", cfg.GetServerAddress()), // Server URL for OAuth callbacks
                cfg.OAuth.Google.ClientID,
                cfg.OAuth.Google.ClientSecret,
                cfg.OAuth.GitHub.ClientID,
                cfg.OAuth.GitHub.ClientSecret,
        )

        // TODO: Initialize WebAuthn service once repository is ready
        // webAuthnService, err := services.NewWebAuthnService(
        //         cfg.WebAuthn.RPID,
        //         cfg.WebAuthn.RPDisplayName,
        //         cfg.WebAuthn.RPOrigins,
        //         credRepo,
        //         userRepo,
        // )
        // if err != nil {
        //         slog.Error("Failed to initialize WebAuthn service", "error", err)
        //         return nil
        // }

        // Initialize middleware
        authMiddleware := middleware.NewAuthMiddleware(authService)

        // Create handlers
        healthHandler := handlers.NewHealthHandler(db)
        authHandler := handlers.NewAuthHandler(authService)

        // Setup routes
        setupRoutes(router, healthHandler, authHandler, authMiddleware)

        // Create HTTP server
        httpServer := &amp;http.Server{
                Addr:           cfg.GetServerAddress(),
                Handler:        router,
                ReadTimeout:    cfg.Server.ReadTimeout,
                WriteTimeout:   cfg.Server.WriteTimeout,
                MaxHeaderBytes: cfg.Server.MaxHeaderBytes,
        }

        return &amp;Server{
                httpServer: httpServer,
                config:     cfg,
                db:         db,
        }</span>
}

// configureOAuthProviders sets up OAuth providers
func configureOAuthProviders(cfg *config.Config) <span class="cov0" title="0">{
        var providers []goth.Provider

        // Configure Google OAuth if enabled
        if cfg.OAuth.Google.Enabled </span><span class="cov0" title="0">{
                providers = append(providers, google.New(
                        cfg.OAuth.Google.ClientID,
                        cfg.OAuth.Google.ClientSecret,
                        cfg.OAuth.Google.CallbackURL,
                        cfg.OAuth.Google.Scopes...,
                ))
        }</span>

        // Configure GitHub OAuth if enabled
        <span class="cov0" title="0">if cfg.OAuth.GitHub.Enabled </span><span class="cov0" title="0">{
                providers = append(providers, github.New(
                        cfg.OAuth.GitHub.ClientID,
                        cfg.OAuth.GitHub.ClientSecret,
                        cfg.OAuth.GitHub.CallbackURL,
                        cfg.OAuth.GitHub.Scopes...,
                ))
        }</span>

        <span class="cov0" title="0">if len(providers) &gt; 0 </span><span class="cov0" title="0">{
                goth.UseProviders(providers...)
                slog.Info("OAuth providers configured", "count", len(providers))
        }</span>
}

// Start starts the HTTP server
func (s *Server) Start() error <span class="cov0" title="0">{
        slog.Info("Starting HTTP server", "address", s.config.GetServerAddress())

        if err := s.httpServer.ListenAndServe(); err != nil &amp;&amp; err != http.ErrServerClosed </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to start server: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Stop gracefully stops the HTTP server
func (s *Server) Stop(ctx context.Context) error <span class="cov0" title="0">{
        slog.Info("Stopping HTTP server")

        return s.httpServer.Shutdown(ctx)
}</span>

// setupRoutes configures all the routes for the application
func setupRoutes(router *gin.Engine, healthHandler *handlers.HealthHandler, authHandler *handlers.AuthHandler, authMiddleware *middleware.AuthMiddleware) <span class="cov0" title="0">{
        // Health check endpoint
        router.GET("/health", healthHandler.Health)
        router.GET("/health/ready", healthHandler.Ready)
        router.GET("/health/live", healthHandler.Live)

        // API version 1
        v1 := router.Group("/v1")
        </span><span class="cov0" title="0">{
                // Authentication routes
                auth := v1.Group("/auth")
                </span><span class="cov0" title="0">{
                        // OAuth endpoints
                        auth.GET("/providers", authHandler.GetProviders)
                        auth.GET("/:provider", authHandler.OAuthLogin)
                        auth.GET("/:provider/callback", authHandler.OAuthCallback)

                        // Token management
                        auth.POST("/refresh", authHandler.RefreshToken)
                        auth.POST("/logout", authHandler.Logout)

                        // Protected routes
                        auth.GET("/profile", authMiddleware.RequireAuth(), authHandler.GetProfile)
                }</span>

                // Protected API routes
                <span class="cov0" title="0">api := v1.Group("/api")
                api.Use(authMiddleware.RequireAuth())
                </span><span class="cov0" title="0">{
                        // Vault routes (placeholder for Phase 3)
                        vault := api.Group("/vault")
                        </span><span class="cov0" title="0">{
                                vault.GET("/status", func(c *gin.Context) </span><span class="cov0" title="0">{
                                        claims, _ := middleware.GetCurrentUser(c)
                                        c.JSON(http.StatusOK, gin.H{
                                                "message": "Vault service ready for Phase 3 implementation",
                                                "version": "1.0.0",
                                                "phase":   "Phase 2 Complete - OAuth Authentication Active",
                                                "user":    claims.Username,
                                        })
                                }</span>)
                        }
                }

                // Public API routes
                <span class="cov0" title="0">public := v1.Group("/public")
                </span><span class="cov0" title="0">{
                        public.GET("/status", func(c *gin.Context) </span><span class="cov0" title="0">{
                                c.JSON(http.StatusOK, gin.H{
                                        "message": "2FAir API",
                                        "version": "1.0.0",
                                        "phase":   "Phase 2 Complete - Hybrid Authentication System",
                                        "features": gin.H{
                                                "oauth":    "enabled",
                                                "webauthn": "planned",
                                                "vault":    "planned",
                                        },
                                })
                        }</span>)
                }
        }
}

// RequestID middleware adds a unique request ID to each request
func RequestID() gin.HandlerFunc <span class="cov0" title="0">{
        return gin.HandlerFunc(func(c *gin.Context) </span><span class="cov0" title="0">{
                requestID := c.GetHeader("X-Request-ID")
                if requestID == "" </span><span class="cov0" title="0">{
                        requestID = generateRequestID()
                }</span>

                <span class="cov0" title="0">c.Header("X-Request-ID", requestID)
                c.Set("requestID", requestID)

                c.Next()</span>
        })
}

// Logger middleware logs HTTP requests
func Logger() gin.HandlerFunc <span class="cov0" title="0">{
        return gin.HandlerFunc(func(c *gin.Context) </span><span class="cov0" title="0">{
                start := time.Now()
                path := c.Request.URL.Path
                query := c.Request.URL.RawQuery

                c.Next()

                end := time.Now()
                latency := end.Sub(start)

                requestID := c.GetString("requestID")

                if query != "" </span><span class="cov0" title="0">{
                        path = path + "?" + query
                }</span>

                <span class="cov0" title="0">slog.Info("HTTP request",
                        "requestID", requestID,
                        "method", c.Request.Method,
                        "path", path,
                        "status", c.Writer.Status(),
                        "latency", latency,
                        "clientIP", c.ClientIP(),
                        "userAgent", c.Request.UserAgent(),
                )</span>
        })
}

// generateRequestID generates a simple request ID
func generateRequestID() string <span class="cov0" title="0">{
        return fmt.Sprintf("%d", time.Now().UnixNano())
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: backup_recovery.sql

package db

import (
        "context"
        "net/netip"

        "github.com/jackc/pgx/v5/pgtype"
)

const createAuditLog = `-- name: CreateAuditLog :one
INSERT INTO audit_logs (
    user_id, device_session_id, event_type,
    event_details, ip_address, user_agent
)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, user_id, device_session_id, event_type, event_details, ip_address, user_agent, created_at
`

type CreateAuditLogParams struct {
        UserID          pgtype.UUID `json:"user_id"`
        DeviceSessionID pgtype.UUID `json:"device_session_id"`
        EventType       string      `json:"event_type"`
        EventDetails    []byte      `json:"event_details"`
        IpAddress       *netip.Addr `json:"ip_address"`
        UserAgent       pgtype.Text `json:"user_agent"`
}

func (q *Queries) CreateAuditLog(ctx context.Context, arg CreateAuditLogParams) (AuditLog, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, createAuditLog,
                arg.UserID,
                arg.DeviceSessionID,
                arg.EventType,
                arg.EventDetails,
                arg.IpAddress,
                arg.UserAgent,
        )
        var i AuditLog
        err := row.Scan(
                &amp;i.ID,
                &amp;i.UserID,
                &amp;i.DeviceSessionID,
                &amp;i.EventType,
                &amp;i.EventDetails,
                &amp;i.IpAddress,
                &amp;i.UserAgent,
                &amp;i.CreatedAt,
        )
        return i, err
}</span>

const createBackupRecoveryCode = `-- name: CreateBackupRecoveryCode :one
INSERT INTO backup_recovery_codes (user_id, encrypted_recovery_blob, salt, hint)
VALUES ($1, $2, $3, $4)
RETURNING id, user_id, encrypted_recovery_blob, salt, hint, created_at, used_at, is_active
`

type CreateBackupRecoveryCodeParams struct {
        UserID                pgtype.UUID `json:"user_id"`
        EncryptedRecoveryBlob []byte      `json:"encrypted_recovery_blob"`
        Salt                  []byte      `json:"salt"`
        Hint                  pgtype.Text `json:"hint"`
}

func (q *Queries) CreateBackupRecoveryCode(ctx context.Context, arg CreateBackupRecoveryCodeParams) (BackupRecoveryCode, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, createBackupRecoveryCode,
                arg.UserID,
                arg.EncryptedRecoveryBlob,
                arg.Salt,
                arg.Hint,
        )
        var i BackupRecoveryCode
        err := row.Scan(
                &amp;i.ID,
                &amp;i.UserID,
                &amp;i.EncryptedRecoveryBlob,
                &amp;i.Salt,
                &amp;i.Hint,
                &amp;i.CreatedAt,
                &amp;i.UsedAt,
                &amp;i.IsActive,
        )
        return i, err
}</span>

const deactivateOldBackupRecoveryCodes = `-- name: DeactivateOldBackupRecoveryCodes :exec
UPDATE backup_recovery_codes
SET is_active = FALSE
WHERE user_id = $1 AND id != $2
`

type DeactivateOldBackupRecoveryCodesParams struct {
        UserID pgtype.UUID `json:"user_id"`
        ID     pgtype.UUID `json:"id"`
}

func (q *Queries) DeactivateOldBackupRecoveryCodes(ctx context.Context, arg DeactivateOldBackupRecoveryCodesParams) error <span class="cov0" title="0">{
        _, err := q.db.Exec(ctx, deactivateOldBackupRecoveryCodes, arg.UserID, arg.ID)
        return err
}</span>

const getActiveBackupRecoveryCode = `-- name: GetActiveBackupRecoveryCode :one
SELECT id, user_id, encrypted_recovery_blob, salt, hint, created_at, used_at, is_active FROM backup_recovery_codes
WHERE user_id = $1 AND is_active = TRUE
ORDER BY created_at DESC
LIMIT 1
`

func (q *Queries) GetActiveBackupRecoveryCode(ctx context.Context, userID pgtype.UUID) (BackupRecoveryCode, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, getActiveBackupRecoveryCode, userID)
        var i BackupRecoveryCode
        err := row.Scan(
                &amp;i.ID,
                &amp;i.UserID,
                &amp;i.EncryptedRecoveryBlob,
                &amp;i.Salt,
                &amp;i.Hint,
                &amp;i.CreatedAt,
                &amp;i.UsedAt,
                &amp;i.IsActive,
        )
        return i, err
}</span>

const getAuditLogsByEventType = `-- name: GetAuditLogsByEventType :many
SELECT id, user_id, device_session_id, event_type, event_details, ip_address, user_agent, created_at FROM audit_logs
WHERE event_type = $1
    AND created_at &gt;= $2
    AND created_at &lt;= $3
ORDER BY created_at DESC
LIMIT $4 OFFSET $5
`

type GetAuditLogsByEventTypeParams struct {
        EventType   string             `json:"event_type"`
        CreatedAt   pgtype.Timestamptz `json:"created_at"`
        CreatedAt_2 pgtype.Timestamptz `json:"created_at_2"`
        Limit       int32              `json:"limit"`
        Offset      int32              `json:"offset"`
}

func (q *Queries) GetAuditLogsByEventType(ctx context.Context, arg GetAuditLogsByEventTypeParams) ([]AuditLog, error) <span class="cov0" title="0">{
        rows, err := q.db.Query(ctx, getAuditLogsByEventType,
                arg.EventType,
                arg.CreatedAt,
                arg.CreatedAt_2,
                arg.Limit,
                arg.Offset,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        items := []AuditLog{}
        for rows.Next() </span><span class="cov0" title="0">{
                var i AuditLog
                if err := rows.Scan(
                        &amp;i.ID,
                        &amp;i.UserID,
                        &amp;i.DeviceSessionID,
                        &amp;i.EventType,
                        &amp;i.EventDetails,
                        &amp;i.IpAddress,
                        &amp;i.UserAgent,
                        &amp;i.CreatedAt,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const getAuditLogsByUserID = `-- name: GetAuditLogsByUserID :many
SELECT id, user_id, device_session_id, event_type, event_details, ip_address, user_agent, created_at FROM audit_logs
WHERE user_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type GetAuditLogsByUserIDParams struct {
        UserID pgtype.UUID `json:"user_id"`
        Limit  int32       `json:"limit"`
        Offset int32       `json:"offset"`
}

func (q *Queries) GetAuditLogsByUserID(ctx context.Context, arg GetAuditLogsByUserIDParams) ([]AuditLog, error) <span class="cov0" title="0">{
        rows, err := q.db.Query(ctx, getAuditLogsByUserID, arg.UserID, arg.Limit, arg.Offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        items := []AuditLog{}
        for rows.Next() </span><span class="cov0" title="0">{
                var i AuditLog
                if err := rows.Scan(
                        &amp;i.ID,
                        &amp;i.UserID,
                        &amp;i.DeviceSessionID,
                        &amp;i.EventType,
                        &amp;i.EventDetails,
                        &amp;i.IpAddress,
                        &amp;i.UserAgent,
                        &amp;i.CreatedAt,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const getBackupRecoveryCodeByID = `-- name: GetBackupRecoveryCodeByID :one
SELECT id, user_id, encrypted_recovery_blob, salt, hint, created_at, used_at, is_active FROM backup_recovery_codes
WHERE id = $1 AND user_id = $2 AND is_active = TRUE
`

type GetBackupRecoveryCodeByIDParams struct {
        ID     pgtype.UUID `json:"id"`
        UserID pgtype.UUID `json:"user_id"`
}

func (q *Queries) GetBackupRecoveryCodeByID(ctx context.Context, arg GetBackupRecoveryCodeByIDParams) (BackupRecoveryCode, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, getBackupRecoveryCodeByID, arg.ID, arg.UserID)
        var i BackupRecoveryCode
        err := row.Scan(
                &amp;i.ID,
                &amp;i.UserID,
                &amp;i.EncryptedRecoveryBlob,
                &amp;i.Salt,
                &amp;i.Hint,
                &amp;i.CreatedAt,
                &amp;i.UsedAt,
                &amp;i.IsActive,
        )
        return i, err
}</span>

const getRecentAuditLogs = `-- name: GetRecentAuditLogs :many
SELECT al.id, al.user_id, al.device_session_id, al.event_type, al.event_details, al.ip_address, al.user_agent, al.created_at, u.username, u.email, ds.device_name
FROM audit_logs al
LEFT JOIN users u ON al.user_id = u.id
LEFT JOIN device_sessions ds ON al.device_session_id = ds.id
WHERE al.created_at &gt;= $1
ORDER BY al.created_at DESC
LIMIT $2 OFFSET $3
`

type GetRecentAuditLogsParams struct {
        CreatedAt pgtype.Timestamptz `json:"created_at"`
        Limit     int32              `json:"limit"`
        Offset    int32              `json:"offset"`
}

type GetRecentAuditLogsRow struct {
        ID              pgtype.UUID        `json:"id"`
        UserID          pgtype.UUID        `json:"user_id"`
        DeviceSessionID pgtype.UUID        `json:"device_session_id"`
        EventType       string             `json:"event_type"`
        EventDetails    []byte             `json:"event_details"`
        IpAddress       *netip.Addr        `json:"ip_address"`
        UserAgent       pgtype.Text        `json:"user_agent"`
        CreatedAt       pgtype.Timestamptz `json:"created_at"`
        Username        pgtype.Text        `json:"username"`
        Email           pgtype.Text        `json:"email"`
        DeviceName      pgtype.Text        `json:"device_name"`
}

func (q *Queries) GetRecentAuditLogs(ctx context.Context, arg GetRecentAuditLogsParams) ([]GetRecentAuditLogsRow, error) <span class="cov0" title="0">{
        rows, err := q.db.Query(ctx, getRecentAuditLogs, arg.CreatedAt, arg.Limit, arg.Offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        items := []GetRecentAuditLogsRow{}
        for rows.Next() </span><span class="cov0" title="0">{
                var i GetRecentAuditLogsRow
                if err := rows.Scan(
                        &amp;i.ID,
                        &amp;i.UserID,
                        &amp;i.DeviceSessionID,
                        &amp;i.EventType,
                        &amp;i.EventDetails,
                        &amp;i.IpAddress,
                        &amp;i.UserAgent,
                        &amp;i.CreatedAt,
                        &amp;i.Username,
                        &amp;i.Email,
                        &amp;i.DeviceName,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const useBackupRecoveryCode = `-- name: UseBackupRecoveryCode :exec
UPDATE backup_recovery_codes
SET used_at = NOW(), is_active = FALSE
WHERE id = $1 AND user_id = $2
`

type UseBackupRecoveryCodeParams struct {
        ID     pgtype.UUID `json:"id"`
        UserID pgtype.UUID `json:"user_id"`
}

func (q *Queries) UseBackupRecoveryCode(ctx context.Context, arg UseBackupRecoveryCodeParams) error <span class="cov0" title="0">{
        _, err := q.db.Exec(ctx, useBackupRecoveryCode, arg.ID, arg.UserID)
        return err
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0

package db

import (
        "context"

        "github.com/jackc/pgx/v5"
        "github.com/jackc/pgx/v5/pgconn"
)

type DBTX interface {
        Exec(context.Context, string, ...interface{}) (pgconn.CommandTag, error)
        Query(context.Context, string, ...interface{}) (pgx.Rows, error)
        QueryRow(context.Context, string, ...interface{}) pgx.Row
}

func New(db DBTX) *Queries <span class="cov0" title="0">{
        return &amp;Queries{db: db}
}</span>

type Queries struct {
        db DBTX
}

func (q *Queries) WithTx(tx pgx.Tx) *Queries <span class="cov0" title="0">{
        return &amp;Queries{
                db: tx,
        }
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: device_sessions.sql

package db

import (
        "context"
        "net/netip"
        "time"

        "github.com/jackc/pgx/v5/pgtype"
)

const cleanupExpiredDeviceSessions = `-- name: CleanupExpiredDeviceSessions :exec
UPDATE device_sessions
SET is_active = FALSE
WHERE expires_at &lt;= NOW()
`

func (q *Queries) CleanupExpiredDeviceSessions(ctx context.Context) error <span class="cov0" title="0">{
        _, err := q.db.Exec(ctx, cleanupExpiredDeviceSessions)
        return err
}</span>

const createDeviceSession = `-- name: CreateDeviceSession :one
INSERT INTO device_sessions (
    user_id, device_id, device_name, device_type,
    user_agent, ip_address, expires_at
)
VALUES ($1, $2, $3, $4, $5, $6, $7)
ON CONFLICT (user_id, device_id)
DO UPDATE SET
    device_name = EXCLUDED.device_name,
    device_type = EXCLUDED.device_type,
    user_agent = EXCLUDED.user_agent,
    ip_address = EXCLUDED.ip_address,
    last_sync_at = NOW(),
    expires_at = EXCLUDED.expires_at,
    is_active = TRUE
RETURNING id, user_id, device_id, device_name, device_type, user_agent, ip_address, last_sync_at, created_at, expires_at, is_active
`

type CreateDeviceSessionParams struct {
        UserID     pgtype.UUID `json:"user_id"`
        DeviceID   string      `json:"device_id"`
        DeviceName string      `json:"device_name"`
        DeviceType string      `json:"device_type"`
        UserAgent  pgtype.Text `json:"user_agent"`
        IpAddress  *netip.Addr `json:"ip_address"`
        ExpiresAt  time.Time   `json:"expires_at"`
}

func (q *Queries) CreateDeviceSession(ctx context.Context, arg CreateDeviceSessionParams) (DeviceSession, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, createDeviceSession,
                arg.UserID,
                arg.DeviceID,
                arg.DeviceName,
                arg.DeviceType,
                arg.UserAgent,
                arg.IpAddress,
                arg.ExpiresAt,
        )
        var i DeviceSession
        err := row.Scan(
                &amp;i.ID,
                &amp;i.UserID,
                &amp;i.DeviceID,
                &amp;i.DeviceName,
                &amp;i.DeviceType,
                &amp;i.UserAgent,
                &amp;i.IpAddress,
                &amp;i.LastSyncAt,
                &amp;i.CreatedAt,
                &amp;i.ExpiresAt,
                &amp;i.IsActive,
        )
        return i, err
}</span>

const createSyncOperation = `-- name: CreateSyncOperation :one
INSERT INTO sync_operations (
    user_id, device_session_id, operation_type,
    resource_type, resource_id, timestamp_vector
)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, user_id, device_session_id, operation_type, resource_type, resource_id, timestamp_vector, created_at
`

type CreateSyncOperationParams struct {
        UserID          pgtype.UUID `json:"user_id"`
        DeviceSessionID pgtype.UUID `json:"device_session_id"`
        OperationType   string      `json:"operation_type"`
        ResourceType    string      `json:"resource_type"`
        ResourceID      pgtype.UUID `json:"resource_id"`
        TimestampVector int64       `json:"timestamp_vector"`
}

func (q *Queries) CreateSyncOperation(ctx context.Context, arg CreateSyncOperationParams) (SyncOperation, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, createSyncOperation,
                arg.UserID,
                arg.DeviceSessionID,
                arg.OperationType,
                arg.ResourceType,
                arg.ResourceID,
                arg.TimestampVector,
        )
        var i SyncOperation
        err := row.Scan(
                &amp;i.ID,
                &amp;i.UserID,
                &amp;i.DeviceSessionID,
                &amp;i.OperationType,
                &amp;i.ResourceType,
                &amp;i.ResourceID,
                &amp;i.TimestampVector,
                &amp;i.CreatedAt,
        )
        return i, err
}</span>

const deactivateDeviceSession = `-- name: DeactivateDeviceSession :exec
UPDATE device_sessions
SET is_active = FALSE
WHERE user_id = $1 AND device_id = $2
`

type DeactivateDeviceSessionParams struct {
        UserID   pgtype.UUID `json:"user_id"`
        DeviceID string      `json:"device_id"`
}

func (q *Queries) DeactivateDeviceSession(ctx context.Context, arg DeactivateDeviceSessionParams) error <span class="cov0" title="0">{
        _, err := q.db.Exec(ctx, deactivateDeviceSession, arg.UserID, arg.DeviceID)
        return err
}</span>

const getActiveDeviceSessionsByUserID = `-- name: GetActiveDeviceSessionsByUserID :many
SELECT id, user_id, device_id, device_name, device_type, user_agent, ip_address, last_sync_at, created_at, expires_at, is_active FROM device_sessions
WHERE user_id = $1 AND is_active = TRUE AND expires_at &gt; NOW()
ORDER BY last_sync_at DESC
`

func (q *Queries) GetActiveDeviceSessionsByUserID(ctx context.Context, userID pgtype.UUID) ([]DeviceSession, error) <span class="cov0" title="0">{
        rows, err := q.db.Query(ctx, getActiveDeviceSessionsByUserID, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        items := []DeviceSession{}
        for rows.Next() </span><span class="cov0" title="0">{
                var i DeviceSession
                if err := rows.Scan(
                        &amp;i.ID,
                        &amp;i.UserID,
                        &amp;i.DeviceID,
                        &amp;i.DeviceName,
                        &amp;i.DeviceType,
                        &amp;i.UserAgent,
                        &amp;i.IpAddress,
                        &amp;i.LastSyncAt,
                        &amp;i.CreatedAt,
                        &amp;i.ExpiresAt,
                        &amp;i.IsActive,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const getDeviceSession = `-- name: GetDeviceSession :one
SELECT id, user_id, device_id, device_name, device_type, user_agent, ip_address, last_sync_at, created_at, expires_at, is_active FROM device_sessions
WHERE user_id = $1 AND device_id = $2 AND is_active = TRUE
`

type GetDeviceSessionParams struct {
        UserID   pgtype.UUID `json:"user_id"`
        DeviceID string      `json:"device_id"`
}

func (q *Queries) GetDeviceSession(ctx context.Context, arg GetDeviceSessionParams) (DeviceSession, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, getDeviceSession, arg.UserID, arg.DeviceID)
        var i DeviceSession
        err := row.Scan(
                &amp;i.ID,
                &amp;i.UserID,
                &amp;i.DeviceID,
                &amp;i.DeviceName,
                &amp;i.DeviceType,
                &amp;i.UserAgent,
                &amp;i.IpAddress,
                &amp;i.LastSyncAt,
                &amp;i.CreatedAt,
                &amp;i.ExpiresAt,
                &amp;i.IsActive,
        )
        return i, err
}</span>

const getLatestSyncTimestamp = `-- name: GetLatestSyncTimestamp :one
SELECT COALESCE(MAX(timestamp_vector), 0) as latest_timestamp
FROM sync_operations
WHERE user_id = $1
`

func (q *Queries) GetLatestSyncTimestamp(ctx context.Context, userID pgtype.UUID) (interface{}, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, getLatestSyncTimestamp, userID)
        var latest_timestamp interface{}
        err := row.Scan(&amp;latest_timestamp)
        return latest_timestamp, err
}</span>

const getSyncOperationsSince = `-- name: GetSyncOperationsSince :many
SELECT so.id, so.user_id, so.device_session_id, so.operation_type, so.resource_type, so.resource_id, so.timestamp_vector, so.created_at, ds.device_id, ds.device_name
FROM sync_operations so
LEFT JOIN device_sessions ds ON so.device_session_id = ds.id
WHERE so.user_id = $1 AND so.timestamp_vector &gt; $2
ORDER BY so.timestamp_vector ASC
`

type GetSyncOperationsSinceParams struct {
        UserID          pgtype.UUID `json:"user_id"`
        TimestampVector int64       `json:"timestamp_vector"`
}

type GetSyncOperationsSinceRow struct {
        ID              pgtype.UUID        `json:"id"`
        UserID          pgtype.UUID        `json:"user_id"`
        DeviceSessionID pgtype.UUID        `json:"device_session_id"`
        OperationType   string             `json:"operation_type"`
        ResourceType    string             `json:"resource_type"`
        ResourceID      pgtype.UUID        `json:"resource_id"`
        TimestampVector int64              `json:"timestamp_vector"`
        CreatedAt       pgtype.Timestamptz `json:"created_at"`
        DeviceID        pgtype.Text        `json:"device_id"`
        DeviceName      pgtype.Text        `json:"device_name"`
}

func (q *Queries) GetSyncOperationsSince(ctx context.Context, arg GetSyncOperationsSinceParams) ([]GetSyncOperationsSinceRow, error) <span class="cov0" title="0">{
        rows, err := q.db.Query(ctx, getSyncOperationsSince, arg.UserID, arg.TimestampVector)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        items := []GetSyncOperationsSinceRow{}
        for rows.Next() </span><span class="cov0" title="0">{
                var i GetSyncOperationsSinceRow
                if err := rows.Scan(
                        &amp;i.ID,
                        &amp;i.UserID,
                        &amp;i.DeviceSessionID,
                        &amp;i.OperationType,
                        &amp;i.ResourceType,
                        &amp;i.ResourceID,
                        &amp;i.TimestampVector,
                        &amp;i.CreatedAt,
                        &amp;i.DeviceID,
                        &amp;i.DeviceName,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const updateDeviceSessionLastSync = `-- name: UpdateDeviceSessionLastSync :exec
UPDATE device_sessions
SET last_sync_at = NOW()
WHERE user_id = $1 AND device_id = $2
`

type UpdateDeviceSessionLastSyncParams struct {
        UserID   pgtype.UUID `json:"user_id"`
        DeviceID string      `json:"device_id"`
}

func (q *Queries) UpdateDeviceSessionLastSync(ctx context.Context, arg UpdateDeviceSessionLastSyncParams) error <span class="cov0" title="0">{
        _, err := q.db.Exec(ctx, updateDeviceSessionLastSync, arg.UserID, arg.DeviceID)
        return err
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: encryption_keys.sql

package db

import (
        "context"

        "github.com/jackc/pgx/v5/pgtype"
)

const createUserEncryptionKey = `-- name: CreateUserEncryptionKey :one
INSERT INTO user_encryption_keys (user_id, key_version, wrapped_dek, salt)
VALUES ($1, $2, $3, $4)
RETURNING id, user_id, key_version, wrapped_dek, salt, created_at, is_active
`

type CreateUserEncryptionKeyParams struct {
        UserID     pgtype.UUID `json:"user_id"`
        KeyVersion int32       `json:"key_version"`
        WrappedDek []byte      `json:"wrapped_dek"`
        Salt       []byte      `json:"salt"`
}

func (q *Queries) CreateUserEncryptionKey(ctx context.Context, arg CreateUserEncryptionKeyParams) (UserEncryptionKey, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, createUserEncryptionKey,
                arg.UserID,
                arg.KeyVersion,
                arg.WrappedDek,
                arg.Salt,
        )
        var i UserEncryptionKey
        err := row.Scan(
                &amp;i.ID,
                &amp;i.UserID,
                &amp;i.KeyVersion,
                &amp;i.WrappedDek,
                &amp;i.Salt,
                &amp;i.CreatedAt,
                &amp;i.IsActive,
        )
        return i, err
}</span>

const deactivateOldUserEncryptionKeys = `-- name: DeactivateOldUserEncryptionKeys :exec
UPDATE user_encryption_keys
SET is_active = FALSE
WHERE user_id = $1 AND key_version &lt; $2
`

type DeactivateOldUserEncryptionKeysParams struct {
        UserID     pgtype.UUID `json:"user_id"`
        KeyVersion int32       `json:"key_version"`
}

func (q *Queries) DeactivateOldUserEncryptionKeys(ctx context.Context, arg DeactivateOldUserEncryptionKeysParams) error <span class="cov0" title="0">{
        _, err := q.db.Exec(ctx, deactivateOldUserEncryptionKeys, arg.UserID, arg.KeyVersion)
        return err
}</span>

const getActiveUserEncryptionKey = `-- name: GetActiveUserEncryptionKey :one
SELECT id, user_id, key_version, wrapped_dek, salt, created_at, is_active FROM user_encryption_keys
WHERE user_id = $1 AND is_active = TRUE
ORDER BY key_version DESC
LIMIT 1
`

func (q *Queries) GetActiveUserEncryptionKey(ctx context.Context, userID pgtype.UUID) (UserEncryptionKey, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, getActiveUserEncryptionKey, userID)
        var i UserEncryptionKey
        err := row.Scan(
                &amp;i.ID,
                &amp;i.UserID,
                &amp;i.KeyVersion,
                &amp;i.WrappedDek,
                &amp;i.Salt,
                &amp;i.CreatedAt,
                &amp;i.IsActive,
        )
        return i, err
}</span>

const getUserEncryptionKeyByVersion = `-- name: GetUserEncryptionKeyByVersion :one
SELECT id, user_id, key_version, wrapped_dek, salt, created_at, is_active FROM user_encryption_keys
WHERE user_id = $1 AND key_version = $2
`

type GetUserEncryptionKeyByVersionParams struct {
        UserID     pgtype.UUID `json:"user_id"`
        KeyVersion int32       `json:"key_version"`
}

func (q *Queries) GetUserEncryptionKeyByVersion(ctx context.Context, arg GetUserEncryptionKeyByVersionParams) (UserEncryptionKey, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, getUserEncryptionKeyByVersion, arg.UserID, arg.KeyVersion)
        var i UserEncryptionKey
        err := row.Scan(
                &amp;i.ID,
                &amp;i.UserID,
                &amp;i.KeyVersion,
                &amp;i.WrappedDek,
                &amp;i.Salt,
                &amp;i.CreatedAt,
                &amp;i.IsActive,
        )
        return i, err
}</span>

const getUserEncryptionKeys = `-- name: GetUserEncryptionKeys :many
SELECT id, user_id, key_version, wrapped_dek, salt, created_at, is_active FROM user_encryption_keys
WHERE user_id = $1
ORDER BY key_version DESC
`

func (q *Queries) GetUserEncryptionKeys(ctx context.Context, userID pgtype.UUID) ([]UserEncryptionKey, error) <span class="cov0" title="0">{
        rows, err := q.db.Query(ctx, getUserEncryptionKeys, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        items := []UserEncryptionKey{}
        for rows.Next() </span><span class="cov0" title="0">{
                var i UserEncryptionKey
                if err := rows.Scan(
                        &amp;i.ID,
                        &amp;i.UserID,
                        &amp;i.KeyVersion,
                        &amp;i.WrappedDek,
                        &amp;i.Salt,
                        &amp;i.CreatedAt,
                        &amp;i.IsActive,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const rotateUserEncryptionKey = `-- name: RotateUserEncryptionKey :one
WITH new_key AS (
    INSERT INTO user_encryption_keys (user_id, key_version, wrapped_dek, salt)
    VALUES ($1, $2, $3, $4)
    RETURNING id, user_id, key_version, wrapped_dek, salt, created_at, is_active
),
deactivate_old AS (
    UPDATE user_encryption_keys
    SET is_active = FALSE
    WHERE user_id = $1 AND key_version &lt; $2
)
SELECT id, user_id, key_version, wrapped_dek, salt, created_at, is_active FROM new_key
`

type RotateUserEncryptionKeyParams struct {
        UserID     pgtype.UUID `json:"user_id"`
        KeyVersion int32       `json:"key_version"`
        WrappedDek []byte      `json:"wrapped_dek"`
        Salt       []byte      `json:"salt"`
}

type RotateUserEncryptionKeyRow struct {
        ID         pgtype.UUID        `json:"id"`
        UserID     pgtype.UUID        `json:"user_id"`
        KeyVersion int32              `json:"key_version"`
        WrappedDek []byte             `json:"wrapped_dek"`
        Salt       []byte             `json:"salt"`
        CreatedAt  pgtype.Timestamptz `json:"created_at"`
        IsActive   pgtype.Bool        `json:"is_active"`
}

func (q *Queries) RotateUserEncryptionKey(ctx context.Context, arg RotateUserEncryptionKeyParams) (RotateUserEncryptionKeyRow, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, rotateUserEncryptionKey,
                arg.UserID,
                arg.KeyVersion,
                arg.WrappedDek,
                arg.Salt,
        )
        var i RotateUserEncryptionKeyRow
        err := row.Scan(
                &amp;i.ID,
                &amp;i.UserID,
                &amp;i.KeyVersion,
                &amp;i.WrappedDek,
                &amp;i.Salt,
                &amp;i.CreatedAt,
                &amp;i.IsActive,
        )
        return i, err
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: totp_seeds.sql

package db

import (
        "context"

        "github.com/jackc/pgx/v5/pgtype"
)

const createEncryptedTOTPSeed = `-- name: CreateEncryptedTOTPSeed :one
INSERT INTO encrypted_totp_seeds (
    user_id, key_version, ciphertext, iv, auth_tag,
    issuer, account_name, icon_url, tags
)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
RETURNING id, user_id, key_version, ciphertext, iv, auth_tag, issuer, account_name, icon_url, tags, created_at, updated_at, synced_at
`

type CreateEncryptedTOTPSeedParams struct {
        UserID      pgtype.UUID `json:"user_id"`
        KeyVersion  int32       `json:"key_version"`
        Ciphertext  []byte      `json:"ciphertext"`
        Iv          []byte      `json:"iv"`
        AuthTag     []byte      `json:"auth_tag"`
        Issuer      string      `json:"issuer"`
        AccountName string      `json:"account_name"`
        IconUrl     pgtype.Text `json:"icon_url"`
        Tags        []string    `json:"tags"`
}

func (q *Queries) CreateEncryptedTOTPSeed(ctx context.Context, arg CreateEncryptedTOTPSeedParams) (EncryptedTotpSeed, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, createEncryptedTOTPSeed,
                arg.UserID,
                arg.KeyVersion,
                arg.Ciphertext,
                arg.Iv,
                arg.AuthTag,
                arg.Issuer,
                arg.AccountName,
                arg.IconUrl,
                arg.Tags,
        )
        var i EncryptedTotpSeed
        err := row.Scan(
                &amp;i.ID,
                &amp;i.UserID,
                &amp;i.KeyVersion,
                &amp;i.Ciphertext,
                &amp;i.Iv,
                &amp;i.AuthTag,
                &amp;i.Issuer,
                &amp;i.AccountName,
                &amp;i.IconUrl,
                &amp;i.Tags,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
                &amp;i.SyncedAt,
        )
        return i, err
}</span>

const deleteEncryptedTOTPSeed = `-- name: DeleteEncryptedTOTPSeed :exec
DELETE FROM encrypted_totp_seeds
WHERE id = $1 AND user_id = $2
`

type DeleteEncryptedTOTPSeedParams struct {
        ID     pgtype.UUID `json:"id"`
        UserID pgtype.UUID `json:"user_id"`
}

func (q *Queries) DeleteEncryptedTOTPSeed(ctx context.Context, arg DeleteEncryptedTOTPSeedParams) error <span class="cov0" title="0">{
        _, err := q.db.Exec(ctx, deleteEncryptedTOTPSeed, arg.ID, arg.UserID)
        return err
}</span>

const getEncryptedTOTPSeedByID = `-- name: GetEncryptedTOTPSeedByID :one
SELECT id, user_id, key_version, ciphertext, iv, auth_tag, issuer, account_name, icon_url, tags, created_at, updated_at, synced_at FROM encrypted_totp_seeds
WHERE id = $1 AND user_id = $2
`

type GetEncryptedTOTPSeedByIDParams struct {
        ID     pgtype.UUID `json:"id"`
        UserID pgtype.UUID `json:"user_id"`
}

func (q *Queries) GetEncryptedTOTPSeedByID(ctx context.Context, arg GetEncryptedTOTPSeedByIDParams) (EncryptedTotpSeed, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, getEncryptedTOTPSeedByID, arg.ID, arg.UserID)
        var i EncryptedTotpSeed
        err := row.Scan(
                &amp;i.ID,
                &amp;i.UserID,
                &amp;i.KeyVersion,
                &amp;i.Ciphertext,
                &amp;i.Iv,
                &amp;i.AuthTag,
                &amp;i.Issuer,
                &amp;i.AccountName,
                &amp;i.IconUrl,
                &amp;i.Tags,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
                &amp;i.SyncedAt,
        )
        return i, err
}</span>

const getEncryptedTOTPSeedsByUserID = `-- name: GetEncryptedTOTPSeedsByUserID :many
SELECT id, user_id, key_version, ciphertext, iv, auth_tag, issuer, account_name, icon_url, tags, created_at, updated_at, synced_at FROM encrypted_totp_seeds
WHERE user_id = $1
ORDER BY created_at DESC
`

func (q *Queries) GetEncryptedTOTPSeedsByUserID(ctx context.Context, userID pgtype.UUID) ([]EncryptedTotpSeed, error) <span class="cov0" title="0">{
        rows, err := q.db.Query(ctx, getEncryptedTOTPSeedsByUserID, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        items := []EncryptedTotpSeed{}
        for rows.Next() </span><span class="cov0" title="0">{
                var i EncryptedTotpSeed
                if err := rows.Scan(
                        &amp;i.ID,
                        &amp;i.UserID,
                        &amp;i.KeyVersion,
                        &amp;i.Ciphertext,
                        &amp;i.Iv,
                        &amp;i.AuthTag,
                        &amp;i.Issuer,
                        &amp;i.AccountName,
                        &amp;i.IconUrl,
                        &amp;i.Tags,
                        &amp;i.CreatedAt,
                        &amp;i.UpdatedAt,
                        &amp;i.SyncedAt,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const getEncryptedTOTPSeedsByUserIDSince = `-- name: GetEncryptedTOTPSeedsByUserIDSince :many
SELECT id, user_id, key_version, ciphertext, iv, auth_tag, issuer, account_name, icon_url, tags, created_at, updated_at, synced_at FROM encrypted_totp_seeds
WHERE user_id = $1 AND updated_at &gt; $2
ORDER BY updated_at ASC
`

type GetEncryptedTOTPSeedsByUserIDSinceParams struct {
        UserID    pgtype.UUID        `json:"user_id"`
        UpdatedAt pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) GetEncryptedTOTPSeedsByUserIDSince(ctx context.Context, arg GetEncryptedTOTPSeedsByUserIDSinceParams) ([]EncryptedTotpSeed, error) <span class="cov0" title="0">{
        rows, err := q.db.Query(ctx, getEncryptedTOTPSeedsByUserIDSince, arg.UserID, arg.UpdatedAt)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        items := []EncryptedTotpSeed{}
        for rows.Next() </span><span class="cov0" title="0">{
                var i EncryptedTotpSeed
                if err := rows.Scan(
                        &amp;i.ID,
                        &amp;i.UserID,
                        &amp;i.KeyVersion,
                        &amp;i.Ciphertext,
                        &amp;i.Iv,
                        &amp;i.AuthTag,
                        &amp;i.Issuer,
                        &amp;i.AccountName,
                        &amp;i.IconUrl,
                        &amp;i.Tags,
                        &amp;i.CreatedAt,
                        &amp;i.UpdatedAt,
                        &amp;i.SyncedAt,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const getTOTPSeedsCountByUser = `-- name: GetTOTPSeedsCountByUser :one
SELECT COUNT(*) FROM encrypted_totp_seeds
WHERE user_id = $1
`

func (q *Queries) GetTOTPSeedsCountByUser(ctx context.Context, userID pgtype.UUID) (int64, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, getTOTPSeedsCountByUser, userID)
        var count int64
        err := row.Scan(&amp;count)
        return count, err
}</span>

const searchEncryptedTOTPSeeds = `-- name: SearchEncryptedTOTPSeeds :many
SELECT id, user_id, key_version, ciphertext, iv, auth_tag, issuer, account_name, icon_url, tags, created_at, updated_at, synced_at FROM encrypted_totp_seeds
WHERE user_id = $1
    AND (
        issuer ILIKE '%' || $2 || '%'
        OR account_name ILIKE '%' || $2 || '%'
        OR $2 = ANY(tags)
    )
ORDER BY created_at DESC
`

type SearchEncryptedTOTPSeedsParams struct {
        UserID  pgtype.UUID `json:"user_id"`
        Column2 pgtype.Text `json:"column_2"`
}

func (q *Queries) SearchEncryptedTOTPSeeds(ctx context.Context, arg SearchEncryptedTOTPSeedsParams) ([]EncryptedTotpSeed, error) <span class="cov0" title="0">{
        rows, err := q.db.Query(ctx, searchEncryptedTOTPSeeds, arg.UserID, arg.Column2)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        items := []EncryptedTotpSeed{}
        for rows.Next() </span><span class="cov0" title="0">{
                var i EncryptedTotpSeed
                if err := rows.Scan(
                        &amp;i.ID,
                        &amp;i.UserID,
                        &amp;i.KeyVersion,
                        &amp;i.Ciphertext,
                        &amp;i.Iv,
                        &amp;i.AuthTag,
                        &amp;i.Issuer,
                        &amp;i.AccountName,
                        &amp;i.IconUrl,
                        &amp;i.Tags,
                        &amp;i.CreatedAt,
                        &amp;i.UpdatedAt,
                        &amp;i.SyncedAt,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const updateEncryptedTOTPSeed = `-- name: UpdateEncryptedTOTPSeed :one
UPDATE encrypted_totp_seeds
SET ciphertext = COALESCE($3, ciphertext),
    iv = COALESCE($4, iv),
    auth_tag = COALESCE($5, auth_tag),
    issuer = COALESCE($6, issuer),
    account_name = COALESCE($7, account_name),
    icon_url = COALESCE($8, icon_url),
    tags = COALESCE($9, tags),
    synced_at = NOW()
WHERE id = $1 AND user_id = $2
RETURNING id, user_id, key_version, ciphertext, iv, auth_tag, issuer, account_name, icon_url, tags, created_at, updated_at, synced_at
`

type UpdateEncryptedTOTPSeedParams struct {
        ID          pgtype.UUID `json:"id"`
        UserID      pgtype.UUID `json:"user_id"`
        Ciphertext  []byte      `json:"ciphertext"`
        Iv          []byte      `json:"iv"`
        AuthTag     []byte      `json:"auth_tag"`
        Issuer      pgtype.Text `json:"issuer"`
        AccountName pgtype.Text `json:"account_name"`
        IconUrl     pgtype.Text `json:"icon_url"`
        Tags        []string    `json:"tags"`
}

func (q *Queries) UpdateEncryptedTOTPSeed(ctx context.Context, arg UpdateEncryptedTOTPSeedParams) (EncryptedTotpSeed, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, updateEncryptedTOTPSeed,
                arg.ID,
                arg.UserID,
                arg.Ciphertext,
                arg.Iv,
                arg.AuthTag,
                arg.Issuer,
                arg.AccountName,
                arg.IconUrl,
                arg.Tags,
        )
        var i EncryptedTotpSeed
        err := row.Scan(
                &amp;i.ID,
                &amp;i.UserID,
                &amp;i.KeyVersion,
                &amp;i.Ciphertext,
                &amp;i.Iv,
                &amp;i.AuthTag,
                &amp;i.Issuer,
                &amp;i.AccountName,
                &amp;i.IconUrl,
                &amp;i.Tags,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
                &amp;i.SyncedAt,
        )
        return i, err
}</span>

const updateTOTPSeedSyncTimestamp = `-- name: UpdateTOTPSeedSyncTimestamp :exec
UPDATE encrypted_totp_seeds
SET synced_at = NOW()
WHERE id = $1 AND user_id = $2
`

type UpdateTOTPSeedSyncTimestampParams struct {
        ID     pgtype.UUID `json:"id"`
        UserID pgtype.UUID `json:"user_id"`
}

func (q *Queries) UpdateTOTPSeedSyncTimestamp(ctx context.Context, arg UpdateTOTPSeedSyncTimestampParams) error <span class="cov0" title="0">{
        _, err := q.db.Exec(ctx, updateTOTPSeedSyncTimestamp, arg.ID, arg.UserID)
        return err
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: users.sql

package db

import (
        "context"

        "github.com/jackc/pgx/v5/pgtype"
)

const createUser = `-- name: CreateUser :one
INSERT INTO users (username, email, display_name)
VALUES ($1, $2, $3)
RETURNING id, username, email, display_name, created_at, updated_at, last_login_at, is_active
`

type CreateUserParams struct {
        Username    string `json:"username"`
        Email       string `json:"email"`
        DisplayName string `json:"display_name"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, createUser, arg.Username, arg.Email, arg.DisplayName)
        var i User
        err := row.Scan(
                &amp;i.ID,
                &amp;i.Username,
                &amp;i.Email,
                &amp;i.DisplayName,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
                &amp;i.LastLoginAt,
                &amp;i.IsActive,
        )
        return i, err
}</span>

const deactivateUser = `-- name: DeactivateUser :exec
UPDATE users
SET is_active = FALSE
WHERE id = $1
`

func (q *Queries) DeactivateUser(ctx context.Context, id pgtype.UUID) error <span class="cov0" title="0">{
        _, err := q.db.Exec(ctx, deactivateUser, id)
        return err
}</span>

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, username, email, display_name, created_at, updated_at, last_login_at, is_active FROM users
WHERE email = $1 AND is_active = TRUE
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, getUserByEmail, email)
        var i User
        err := row.Scan(
                &amp;i.ID,
                &amp;i.Username,
                &amp;i.Email,
                &amp;i.DisplayName,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
                &amp;i.LastLoginAt,
                &amp;i.IsActive,
        )
        return i, err
}</span>

const getUserByID = `-- name: GetUserByID :one
SELECT id, username, email, display_name, created_at, updated_at, last_login_at, is_active FROM users
WHERE id = $1 AND is_active = TRUE
`

func (q *Queries) GetUserByID(ctx context.Context, id pgtype.UUID) (User, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, getUserByID, id)
        var i User
        err := row.Scan(
                &amp;i.ID,
                &amp;i.Username,
                &amp;i.Email,
                &amp;i.DisplayName,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
                &amp;i.LastLoginAt,
                &amp;i.IsActive,
        )
        return i, err
}</span>

const getUserByUsername = `-- name: GetUserByUsername :one
SELECT id, username, email, display_name, created_at, updated_at, last_login_at, is_active FROM users
WHERE username = $1 AND is_active = TRUE
`

func (q *Queries) GetUserByUsername(ctx context.Context, username string) (User, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, getUserByUsername, username)
        var i User
        err := row.Scan(
                &amp;i.ID,
                &amp;i.Username,
                &amp;i.Email,
                &amp;i.DisplayName,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
                &amp;i.LastLoginAt,
                &amp;i.IsActive,
        )
        return i, err
}</span>

const updateUser = `-- name: UpdateUser :one
UPDATE users
SET username = COALESCE($2, username),
    email = COALESCE($3, email),
    display_name = COALESCE($4, display_name)
WHERE id = $1
RETURNING id, username, email, display_name, created_at, updated_at, last_login_at, is_active
`

type UpdateUserParams struct {
        ID          pgtype.UUID `json:"id"`
        Username    pgtype.Text `json:"username"`
        Email       pgtype.Text `json:"email"`
        DisplayName pgtype.Text `json:"display_name"`
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) (User, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, updateUser,
                arg.ID,
                arg.Username,
                arg.Email,
                arg.DisplayName,
        )
        var i User
        err := row.Scan(
                &amp;i.ID,
                &amp;i.Username,
                &amp;i.Email,
                &amp;i.DisplayName,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
                &amp;i.LastLoginAt,
                &amp;i.IsActive,
        )
        return i, err
}</span>

const updateUserLastLogin = `-- name: UpdateUserLastLogin :exec
UPDATE users
SET last_login_at = NOW()
WHERE id = $1
`

func (q *Queries) UpdateUserLastLogin(ctx context.Context, id pgtype.UUID) error <span class="cov0" title="0">{
        _, err := q.db.Exec(ctx, updateUserLastLogin, id)
        return err
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: webauthn.sql

package db

import (
        "context"

        "github.com/jackc/pgx/v5/pgtype"
)

const createWebAuthnCredential = `-- name: CreateWebAuthnCredential :one
INSERT INTO webauthn_credentials (
    user_id, credential_id, public_key, aaguid, clone_warning,
    attachment, transport, backup_eligible, backup_state, sign_count
)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
RETURNING id, user_id, credential_id, public_key, aaguid, clone_warning, attachment, transport, backup_eligible, backup_state, sign_count, created_at, last_used_at
`

type CreateWebAuthnCredentialParams struct {
        UserID         pgtype.UUID `json:"user_id"`
        CredentialID   []byte      `json:"credential_id"`
        PublicKey      []byte      `json:"public_key"`
        Aaguid         pgtype.UUID `json:"aaguid"`
        CloneWarning   pgtype.Bool `json:"clone_warning"`
        Attachment     pgtype.Text `json:"attachment"`
        Transport      []string    `json:"transport"`
        BackupEligible pgtype.Bool `json:"backup_eligible"`
        BackupState    pgtype.Bool `json:"backup_state"`
        SignCount      pgtype.Int8 `json:"sign_count"`
}

func (q *Queries) CreateWebAuthnCredential(ctx context.Context, arg CreateWebAuthnCredentialParams) (WebauthnCredential, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, createWebAuthnCredential,
                arg.UserID,
                arg.CredentialID,
                arg.PublicKey,
                arg.Aaguid,
                arg.CloneWarning,
                arg.Attachment,
                arg.Transport,
                arg.BackupEligible,
                arg.BackupState,
                arg.SignCount,
        )
        var i WebauthnCredential
        err := row.Scan(
                &amp;i.ID,
                &amp;i.UserID,
                &amp;i.CredentialID,
                &amp;i.PublicKey,
                &amp;i.Aaguid,
                &amp;i.CloneWarning,
                &amp;i.Attachment,
                &amp;i.Transport,
                &amp;i.BackupEligible,
                &amp;i.BackupState,
                &amp;i.SignCount,
                &amp;i.CreatedAt,
                &amp;i.LastUsedAt,
        )
        return i, err
}</span>

const deleteWebAuthnCredential = `-- name: DeleteWebAuthnCredential :exec
DELETE FROM webauthn_credentials
WHERE credential_id = $1 AND user_id = $2
`

type DeleteWebAuthnCredentialParams struct {
        CredentialID []byte      `json:"credential_id"`
        UserID       pgtype.UUID `json:"user_id"`
}

func (q *Queries) DeleteWebAuthnCredential(ctx context.Context, arg DeleteWebAuthnCredentialParams) error <span class="cov0" title="0">{
        _, err := q.db.Exec(ctx, deleteWebAuthnCredential, arg.CredentialID, arg.UserID)
        return err
}</span>

const getWebAuthnCredentialByID = `-- name: GetWebAuthnCredentialByID :one
SELECT id, user_id, credential_id, public_key, aaguid, clone_warning, attachment, transport, backup_eligible, backup_state, sign_count, created_at, last_used_at FROM webauthn_credentials
WHERE credential_id = $1
`

func (q *Queries) GetWebAuthnCredentialByID(ctx context.Context, credentialID []byte) (WebauthnCredential, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, getWebAuthnCredentialByID, credentialID)
        var i WebauthnCredential
        err := row.Scan(
                &amp;i.ID,
                &amp;i.UserID,
                &amp;i.CredentialID,
                &amp;i.PublicKey,
                &amp;i.Aaguid,
                &amp;i.CloneWarning,
                &amp;i.Attachment,
                &amp;i.Transport,
                &amp;i.BackupEligible,
                &amp;i.BackupState,
                &amp;i.SignCount,
                &amp;i.CreatedAt,
                &amp;i.LastUsedAt,
        )
        return i, err
}</span>

const getWebAuthnCredentialsByUserID = `-- name: GetWebAuthnCredentialsByUserID :many
SELECT id, user_id, credential_id, public_key, aaguid, clone_warning, attachment, transport, backup_eligible, backup_state, sign_count, created_at, last_used_at FROM webauthn_credentials
WHERE user_id = $1
ORDER BY created_at DESC
`

func (q *Queries) GetWebAuthnCredentialsByUserID(ctx context.Context, userID pgtype.UUID) ([]WebauthnCredential, error) <span class="cov0" title="0">{
        rows, err := q.db.Query(ctx, getWebAuthnCredentialsByUserID, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        items := []WebauthnCredential{}
        for rows.Next() </span><span class="cov0" title="0">{
                var i WebauthnCredential
                if err := rows.Scan(
                        &amp;i.ID,
                        &amp;i.UserID,
                        &amp;i.CredentialID,
                        &amp;i.PublicKey,
                        &amp;i.Aaguid,
                        &amp;i.CloneWarning,
                        &amp;i.Attachment,
                        &amp;i.Transport,
                        &amp;i.BackupEligible,
                        &amp;i.BackupState,
                        &amp;i.SignCount,
                        &amp;i.CreatedAt,
                        &amp;i.LastUsedAt,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const updateWebAuthnCredentialCloneWarning = `-- name: UpdateWebAuthnCredentialCloneWarning :exec
UPDATE webauthn_credentials
SET clone_warning = $2
WHERE credential_id = $1
`

type UpdateWebAuthnCredentialCloneWarningParams struct {
        CredentialID []byte      `json:"credential_id"`
        CloneWarning pgtype.Bool `json:"clone_warning"`
}

func (q *Queries) UpdateWebAuthnCredentialCloneWarning(ctx context.Context, arg UpdateWebAuthnCredentialCloneWarningParams) error <span class="cov0" title="0">{
        _, err := q.db.Exec(ctx, updateWebAuthnCredentialCloneWarning, arg.CredentialID, arg.CloneWarning)
        return err
}</span>

const updateWebAuthnCredentialSignCount = `-- name: UpdateWebAuthnCredentialSignCount :exec
UPDATE webauthn_credentials
SET sign_count = $2, last_used_at = NOW()
WHERE credential_id = $1
`

type UpdateWebAuthnCredentialSignCountParams struct {
        CredentialID []byte      `json:"credential_id"`
        SignCount    pgtype.Int8 `json:"sign_count"`
}

func (q *Queries) UpdateWebAuthnCredentialSignCount(ctx context.Context, arg UpdateWebAuthnCredentialSignCountParams) error <span class="cov0" title="0">{
        _, err := q.db.Exec(ctx, updateWebAuthnCredentialSignCount, arg.CredentialID, arg.SignCount)
        return err
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">package database

import (
        "context"
        "errors"
        "fmt"
        "time"

        "github.com/google/uuid"
        "github.com/jackc/pgx/v5"
        "github.com/jackc/pgx/v5/pgtype"

        db "github.com/bug-breeder/2fair/server/internal/adapter/database/sqlc"
        "github.com/bug-breeder/2fair/server/internal/domain/entities"
        "github.com/bug-breeder/2fair/server/internal/domain/repositories"
        "github.com/bug-breeder/2fair/server/internal/infrastructure/database"
)

// UserRepository implements the domain user repository interface
type UserRepository struct {
        dbConn  *database.DB
        queries *db.Queries
}

// NewUserRepository creates a new user repository
func NewUserRepository(dbConn *database.DB) repositories.UserRepository <span class="cov0" title="0">{
        return &amp;UserRepository{
                dbConn:  dbConn,
                queries: db.New(dbConn.Pool),
        }
}</span>

// Create creates a new user
func (r *UserRepository) Create(ctx context.Context, user *entities.User) error <span class="cov0" title="0">{
        // Use the generated CreateUser query which returns a User
        dbUser, err := r.queries.CreateUser(ctx, db.CreateUserParams{
                Username:    user.Username,
                Email:       user.Email,
                DisplayName: user.DisplayName,
        })
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create user: %w", err)
        }</span>

        // Update the user entity with generated values
        <span class="cov0" title="0">user.ID = convertPGUUID(dbUser.ID)
        user.CreatedAt = convertPGTimestamp(dbUser.CreatedAt)
        user.UpdatedAt = convertPGTimestamp(dbUser.UpdatedAt)
        user.IsActive = convertPGBool(dbUser.IsActive)

        return nil</span>
}

// GetByID retrieves a user by ID
func (r *UserRepository) GetByID(ctx context.Context, id uuid.UUID) (*entities.User, error) <span class="cov0" title="0">{
        pgID := convertUUIDToPG(id)
        row, err := r.queries.GetUserByID(ctx, pgID)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, pgx.ErrNoRows) </span><span class="cov0" title="0">{
                        return nil, entities.ErrUserNotFound
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get user by ID: %w", err)</span>
        }

        <span class="cov0" title="0">return convertDBUserToEntity(row), nil</span>
}

// GetByEmail retrieves a user by email
func (r *UserRepository) GetByEmail(ctx context.Context, email string) (*entities.User, error) <span class="cov0" title="0">{
        row, err := r.queries.GetUserByEmail(ctx, email)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, pgx.ErrNoRows) </span><span class="cov0" title="0">{
                        return nil, entities.ErrUserNotFound
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get user by email: %w", err)</span>
        }

        <span class="cov0" title="0">return convertDBUserToEntity(row), nil</span>
}

// GetByUsername retrieves a user by username
func (r *UserRepository) GetByUsername(ctx context.Context, username string) (*entities.User, error) <span class="cov0" title="0">{
        row, err := r.queries.GetUserByUsername(ctx, username)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, pgx.ErrNoRows) </span><span class="cov0" title="0">{
                        return nil, entities.ErrUserNotFound
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get user by username: %w", err)</span>
        }

        <span class="cov0" title="0">return convertDBUserToEntity(row), nil</span>
}

// Update updates an existing user
func (r *UserRepository) Update(ctx context.Context, user *entities.User) error <span class="cov0" title="0">{
        // Use the generated UpdateUser query
        dbUser, err := r.queries.UpdateUser(ctx, db.UpdateUserParams{
                ID:          convertUUIDToPG(user.ID),
                Username:    pgtype.Text{String: user.Username, Valid: true},
                Email:       pgtype.Text{String: user.Email, Valid: true},
                DisplayName: pgtype.Text{String: user.DisplayName, Valid: true},
        })
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, pgx.ErrNoRows) </span><span class="cov0" title="0">{
                        return entities.ErrUserNotFound
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("failed to update user: %w", err)</span>
        }

        // Update the entity with the returned values
        <span class="cov0" title="0">user.UpdatedAt = convertPGTimestamp(dbUser.UpdatedAt)

        return nil</span>
}

// UpdateLastLogin updates the user's last login timestamp
func (r *UserRepository) UpdateLastLogin(ctx context.Context, userID uuid.UUID) error <span class="cov0" title="0">{
        pgID := convertUUIDToPG(userID)
        err := r.queries.UpdateUserLastLogin(ctx, pgID)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, pgx.ErrNoRows) </span><span class="cov0" title="0">{
                        return entities.ErrUserNotFound
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("failed to update last login: %w", err)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// Deactivate marks a user as inactive (soft delete)
func (r *UserRepository) Deactivate(ctx context.Context, userID uuid.UUID) error <span class="cov0" title="0">{
        pgID := convertUUIDToPG(userID)
        err := r.queries.DeactivateUser(ctx, pgID)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, pgx.ErrNoRows) </span><span class="cov0" title="0">{
                        return entities.ErrUserNotFound
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("failed to deactivate user: %w", err)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// ExistsByEmail checks if a user exists by email
func (r *UserRepository) ExistsByEmail(ctx context.Context, email string) (bool, error) <span class="cov0" title="0">{
        _, err := r.queries.GetUserByEmail(ctx, email)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, pgx.ErrNoRows) </span><span class="cov0" title="0">{
                        return false, nil
                }</span>
                <span class="cov0" title="0">return false, fmt.Errorf("failed to check user existence by email: %w", err)</span>
        }
        <span class="cov0" title="0">return true, nil</span>
}

// ExistsByUsername checks if a user exists by username
func (r *UserRepository) ExistsByUsername(ctx context.Context, username string) (bool, error) <span class="cov0" title="0">{
        _, err := r.queries.GetUserByUsername(ctx, username)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, pgx.ErrNoRows) </span><span class="cov0" title="0">{
                        return false, nil
                }</span>
                <span class="cov0" title="0">return false, fmt.Errorf("failed to check user existence by username: %w", err)</span>
        }
        <span class="cov0" title="0">return true, nil</span>
}

// Note: List and Count methods are not implemented yet as the SQLC queries are not generated
// These will be added in a future iteration when we have the proper queries

// Helper functions to convert between pgtype and Go types

func convertUUIDToPG(id uuid.UUID) pgtype.UUID <span class="cov0" title="0">{
        return pgtype.UUID{
                Bytes: id,
                Valid: true,
        }
}</span>

func convertPGUUID(pgID pgtype.UUID) uuid.UUID <span class="cov0" title="0">{
        if !pgID.Valid </span><span class="cov0" title="0">{
                return uuid.Nil
        }</span>
        <span class="cov0" title="0">return pgID.Bytes</span>
}

func convertPGTimestamp(pgTime pgtype.Timestamptz) time.Time <span class="cov0" title="0">{
        if !pgTime.Valid </span><span class="cov0" title="0">{
                return time.Time{}
        }</span>
        <span class="cov0" title="0">return pgTime.Time</span>
}

func convertPGBool(pgBool pgtype.Bool) bool <span class="cov0" title="0">{
        if !pgBool.Valid </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return pgBool.Bool</span>
}

func convertDBUserToEntity(dbUser db.User) *entities.User <span class="cov0" title="0">{
        user := &amp;entities.User{
                ID:          convertPGUUID(dbUser.ID),
                Username:    dbUser.Username,
                Email:       dbUser.Email,
                DisplayName: dbUser.DisplayName,
                CreatedAt:   convertPGTimestamp(dbUser.CreatedAt),
                UpdatedAt:   convertPGTimestamp(dbUser.UpdatedAt),
                IsActive:    convertPGBool(dbUser.IsActive),
        }

        // Handle nullable last login timestamp
        if dbUser.LastLoginAt.Valid </span><span class="cov0" title="0">{
                loginTime := dbUser.LastLoginAt.Time
                user.LastLoginAt = &amp;loginTime
        }</span>

        <span class="cov0" title="0">return user</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package controller

import (
        "context"
        "log/slog"
        "net/http"

        "github.com/bug-breeder/2fair/server/internal/domain/dto"
        "github.com/bug-breeder/2fair/server/internal/domain/models"
        "github.com/bug-breeder/2fair/server/internal/infrastructure/configs"
        "github.com/bug-breeder/2fair/server/internal/usecase"
        "github.com/gin-gonic/gin"
        "github.com/markbates/goth/gothic"
)

// AuthController handles authentication-related HTTP requests
type AuthController struct {
        authUseCase *usecase.AuthUseCase
        logger      *slog.Logger
}

// NewAuthController creates a new auth controller instance
func NewAuthController(authUseCase *usecase.AuthUseCase) *AuthController <span class="cov0" title="0">{
        return &amp;AuthController{
                authUseCase: authUseCase,
                logger:      slog.Default().With("component", "AuthController"),
        }
}</span>

// @Summary Login with Google
// @Description Authenticate a user using Google OAuth
// @Tags auth
// @Accept json
// @Produce json
// @Success 200 {object} models.User
// @Failure 400 {object} map[string]string
// @Failure 500 {object} map[string]string
// @Router /api/v1/auth/google [get]
func (ctrl *AuthController) GoogleLogin(ctx *gin.Context) <span class="cov0" title="0">{
        provider := ctx.Param("provider")
        if provider == "" </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusBadRequest, gin.H{"error": "Provider is required"})
                return
        }</span>

        <span class="cov0" title="0">ctx.Request = ctx.Request.WithContext(context.WithValue(ctx.Request.Context(), "provider", provider))
        gothic.BeginAuthHandler(ctx.Writer, ctx.Request)</span>
}

// @Summary Google OAuth callback
// @Description Handle the callback from Google OAuth
// @Tags auth
// @Accept json
// @Produce json
// @Success 200 {object} map[string]string
// @Failure 400 {object} map[string]string
// @Failure 500 {object} map[string]string
// @Router /api/v1/auth/google/callback [get]
func (ctrl *AuthController) GoogleCallback(ctx *gin.Context) <span class="cov0" title="0">{
        user, err := gothic.CompleteUserAuth(ctx.Writer, ctx.Request)
        if err != nil </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to complete user auth"})
                return
        }</span>

        <span class="cov0" title="0">newUser := &amp;models.User{
                Name:       user.Name,
                Email:      user.Email,
                Provider:   user.Provider,
                ProviderID: user.UserID,
        }

        accessToken, refreshToken, err := ctrl.authUseCase.CompleteUserAuth(ctx, newUser, ctx.ClientIP(), ctx.Request.UserAgent())
        if err != nil </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to complete user auth"})
                return
        }</span>

        <span class="cov0" title="0">client_domain := configs.GetEnv("CLIENT_DOMAIN")

        http.SetCookie(ctx.Writer, &amp;http.Cookie{
                Name:     "refresh_token",
                Value:    refreshToken,
                Path:     "/auth/refresh",
                Domain:   client_domain,
                HttpOnly: true,
                Secure:   true,
        })

        http.SetCookie(ctx.Writer, &amp;http.Cookie{
                Name:     "access_token",
                Value:    accessToken,
                Path:     "/",
                Domain:   client_domain,
                HttpOnly: true,
                Secure:   true,
        })

        ctx.Redirect(http.StatusFound, client_domain)</span>
}

// @Summary Get current user
// @Description Get the currently authenticated user's information
// @Tags auth
// @Accept json
// @Produce json
// @Security BearerAuth
// @Success 200 {object} models.User
// @Failure 401 {object} map[string]string
// @Failure 500 {object} map[string]string
// @Router /api/v1/auth/me [get]
func (ctrl *AuthController) GetCurrentUser(ctx *gin.Context) <span class="cov0" title="0">{
        userID, exists := ctx.Get("userID")
        if !exists </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusUnauthorized, gin.H{"error": "User ID not found in context"})
                return
        }</span>

        <span class="cov0" title="0">userIDStr, ok := userID.(string)
        if !ok </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusInternalServerError, gin.H{"error": "Invalid user ID format"})
                return
        }</span>

        <span class="cov0" title="0">user, err := ctrl.authUseCase.GetCurrentUser(ctx, userIDStr)
        if err != nil </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get user information"})
                return
        }</span>

        <span class="cov0" title="0">ctx.JSON(http.StatusOK, user)</span>
}

// @Summary Logout user
// @Description Logout user by clearing refresh token cookie
// @Tags auth
// @Accept json
// @Produce json
// @Success 200 {object} dto.MessageResponse
// @Router /api/v1/auth/logout [post]
func (ctrl *AuthController) Logout(c *gin.Context) <span class="cov0" title="0">{
        ctrl.logger.Info("User logout request")

        // Clear the refresh token cookie
        c.SetCookie(
                "refresh_token",
                "",
                -1, // Expire immediately
                "/",
                "",
                false,
                true, // HttpOnly
        )

        // Clear the access token cookie if it exists
        c.SetCookie(
                "access_token",
                "",
                -1, // Expire immediately
                "/",
                "",
                false,
                true, // HttpOnly
        )

        ctrl.logger.Info("User logged out successfully")
        c.JSON(http.StatusOK, dto.MessageResponse{Message: "Logged out successfully"})
}</span>

// @Summary Refresh access token
// @Description Refresh the access token using the refresh token cookie
// @Tags auth
// @Accept json
// @Produce json
// @Success 200 {object} dto.MessageResponse
// @Failure 401 {object} dto.ErrorResponse
// @Failure 500 {object} dto.ErrorResponse
// @Router /api/v1/auth/refresh [post]
func (ctrl *AuthController) RefreshToken(c *gin.Context) <span class="cov0" title="0">{
        refreshTokenCookie, err := c.Request.Cookie("refresh_token")
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, dto.ErrorResponse{Error: "Refresh token is missing"})
                return
        }</span>

        <span class="cov0" title="0">refreshToken := refreshTokenCookie.Value
        claims, err := ctrl.authUseCase.ValidateToken(refreshToken)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, dto.ErrorResponse{Error: "Invalid refresh token"})
                return
        }</span>

        <span class="cov0" title="0">accessToken, err := ctrl.authUseCase.RefreshTokens(c, claims)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, dto.ErrorResponse{Error: "Failed to refresh tokens"})
                return
        }</span>

        <span class="cov0" title="0">http.SetCookie(c.Writer, &amp;http.Cookie{
                Name:     "access_token",
                Value:    accessToken,
                Path:     "/",
                HttpOnly: true,
                Secure:   true,
        })

        c.JSON(http.StatusOK, dto.MessageResponse{Message: "Tokens refreshed"})</span>
}

// @Summary Get login history
// @Description Get the login history for the authenticated user
// @Tags auth
// @Accept json
// @Produce json
// @Success 200 {array} models.LoginEvent
// @Failure 401 {object} dto.ErrorResponse
// @Failure 500 {object} dto.ErrorResponse
// @Router /api/v1/login-history [get]
func (ctrl *AuthController) GetLoginHistory(c *gin.Context) <span class="cov0" title="0">{
        userID := c.MustGet("userID").(string)
        loginHistory, err := ctrl.authUseCase.GetLoginHistory(c, userID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, dto.ErrorResponse{Error: "Failed to fetch login history"})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, loginHistory)</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package controller

import (
        "log/slog"
        "net/http"

        "github.com/bug-breeder/2fair/server/internal/domain/dto"
        "github.com/bug-breeder/2fair/server/internal/domain/models"
        "github.com/bug-breeder/2fair/server/internal/usecase"
        "github.com/gin-gonic/gin"
        "go.mongodb.org/mongo-driver/mongo"
)

// OTPController handles OTP-related HTTP requests
type OTPController struct {
        otpUseCase *usecase.OTPUseCase
        logger     *slog.Logger
}

// NewOTPController creates a new OTP controller instance
func NewOTPController(otpUseCase *usecase.OTPUseCase) *OTPController <span class="cov0" title="0">{
        return &amp;OTPController{
                otpUseCase: otpUseCase,
                logger:     slog.Default().With("component", "OTPController"),
        }
}</span>

// @Summary Add OTP
// @Description Add a new OTP for the authenticated user
// @Tags otp
// @Accept json
// @Produce json
// @Security BearerAuth
// @Param otp body models.OTP true "OTP details"
// @Success 200 {object} map[string]string
// @Failure 400 {object} map[string]string
// @Failure 401 {object} map[string]string
// @Failure 500 {object} map[string]string
// @Router /api/v1/otp [post]
func (ctrl *OTPController) AddOTP(c *gin.Context) <span class="cov0" title="0">{
        userID := c.MustGet("userID").(string)
        var otp models.OTP
        if err := c.ShouldBindJSON(&amp;otp); err != nil </span><span class="cov0" title="0">{
                ctrl.logger.Warn("Invalid OTP request body",
                        "userID", userID,
                        "error", err)
                c.JSON(http.StatusBadRequest, dto.ErrorResponse{Error: err.Error()})
                return
        }</span>

        <span class="cov0" title="0">err := ctrl.otpUseCase.AddOTP(c, userID, &amp;otp)
        if err != nil </span><span class="cov0" title="0">{
                ctrl.logger.Error("Failed to add OTP",
                        "userID", userID,
                        "issuer", otp.Issuer,
                        "error", err)
                c.JSON(http.StatusInternalServerError, dto.ErrorResponse{Error: "Failed to add OTP"})
                return
        }</span>

        <span class="cov0" title="0">ctrl.logger.Info("OTP added via API",
                "userID", userID,
                "issuer", otp.Issuer)
        c.JSON(http.StatusOK, otp)</span>
}

// @Summary List OTPs
// @Description Get all OTPs for the authenticated user
// @Tags otp
// @Accept json
// @Produce json
// @Security BearerAuth
// @Success 200 {array} models.OTP
// @Failure 401 {object} map[string]string
// @Failure 500 {object} map[string]string
// @Router /api/v1/otp [get]
func (ctrl *OTPController) ListOTPs(c *gin.Context) <span class="cov0" title="0">{
        userID := c.MustGet("userID").(string)

        otps, err := ctrl.otpUseCase.ListOTPs(c, userID)
        if err != nil </span><span class="cov0" title="0">{
                if err == mongo.ErrNoDocuments </span><span class="cov0" title="0">{
                        ctrl.logger.Warn("No OTPs found for user", "userID", userID)
                        c.JSON(http.StatusNotFound, dto.ErrorResponse{Error: "User not found"})
                        return
                }</span>
                <span class="cov0" title="0">ctrl.logger.Error("Failed to list OTPs",
                        "userID", userID,
                        "error", err)
                c.JSON(http.StatusInternalServerError, dto.ErrorResponse{Error: "Failed to fetch OTPs"})
                return</span>
        }

        <span class="cov0" title="0">var otpsResponse []dto.ListOTPsResponse
        for _, otp := range otps </span><span class="cov0" title="0">{
                otpsResponse = append(otpsResponse, dto.ListOTPsResponse{
                        ID:        otp.ID,
                        Issuer:    otp.Issuer,
                        Label:     otp.Label,
                        Algorithm: otp.Algorithm,
                        Digits:    otp.Digits,
                        Period:    otp.Period,
                        Counter:   otp.Counter,
                        Method:    otp.Method,
                })
        }</span>

        <span class="cov0" title="0">ctrl.logger.Debug("Listed OTPs via API",
                "userID", userID,
                "count", len(otpsResponse))
        c.JSON(http.StatusOK, otpsResponse)</span>
}

// @Summary Edit OTP
// @Description Edit an existing OTP
// @Tags otp
// @Accept json
// @Produce json
// @Security BearerAuth
// @Param id path int true "OTP ID"
// @Param otp body models.OTP true "Updated OTP details"
// @Success 200 {object} map[string]string
// @Failure 400 {object} map[string]string
// @Failure 401 {object} map[string]string
// @Failure 500 {object} map[string]string
// @Router /api/v1/otp/{id} [put]
func (ctrl *OTPController) EditOTP(c *gin.Context) <span class="cov0" title="0">{
        userID := c.MustGet("userID").(string)
        otpID := c.Param("id")

        ctrl.logger.Info("EditOTP request received",
                "userID", userID,
                "otpID", otpID)

        var updatedOTP models.OTP
        if err := c.ShouldBindJSON(&amp;updatedOTP); err != nil </span><span class="cov0" title="0">{
                ctrl.logger.Warn("Invalid edit OTP request body",
                        "userID", userID,
                        "otpID", otpID,
                        "error", err)
                c.JSON(http.StatusBadRequest, dto.ErrorResponse{Error: err.Error()})
                return
        }</span>

        <span class="cov0" title="0">ctrl.logger.Info("EditOTP parsed request body",
                "userID", userID,
                "otpID", otpID,
                "updatedOTP", updatedOTP)

        err := ctrl.otpUseCase.EditOTP(c, userID, otpID, &amp;updatedOTP)
        if err != nil </span><span class="cov0" title="0">{
                ctrl.logger.Error("Failed to edit OTP",
                        "userID", userID,
                        "otpID", otpID,
                        "error", err)
                c.JSON(http.StatusInternalServerError, dto.ErrorResponse{Error: "Failed to edit OTP"})
                return
        }</span>

        <span class="cov0" title="0">ctrl.logger.Info("OTP edited successfully via API",
                "userID", userID,
                "otpID", otpID,
                "newIssuer", updatedOTP.Issuer)
        c.JSON(http.StatusOK, dto.MessageResponse{Message: "OTP updated"})</span>
}

// @Summary Inactivate OTP
// @Description Mark an OTP as inactive
// @Tags otp
// @Accept json
// @Produce json
// @Security BearerAuth
// @Param id path int true "OTP ID"
// @Success 200 {object} map[string]string
// @Failure 400 {object} map[string]string
// @Failure 401 {object} map[string]string
// @Failure 500 {object} map[string]string
// @Router /api/v1/otp/{id}/inactivate [post]
func (ctrl *OTPController) InactivateOTP(c *gin.Context) <span class="cov0" title="0">{
        userID := c.MustGet("userID").(string)
        otpID := c.Param("id")

        err := ctrl.otpUseCase.InactivateOTP(c, userID, otpID)
        if err != nil </span><span class="cov0" title="0">{
                ctrl.logger.Error("Failed to inactivate OTP",
                        "userID", userID,
                        "otpID", otpID,
                        "error", err)
                c.JSON(http.StatusInternalServerError, dto.ErrorResponse{Error: "Failed to inactivate OTP"})
                return
        }</span>

        <span class="cov0" title="0">ctrl.logger.Info("OTP inactivated via API",
                "userID", userID,
                "otpID", otpID)
        c.JSON(http.StatusOK, dto.MessageResponse{Message: "OTP inactivated"})</span>
}

// @Summary Generate OTP codes
// @Description Generate current and next OTP codes for the user
// @Tags otp
// @Accept json
// @Produce json
// @Security BearerAuth
// @Success 200 {array} dto.GenerateOTPCodesResponse
// @Failure 401 {object} dto.ErrorResponse
// @Failure 404 {object} dto.ErrorResponse
// @Failure 500 {object} dto.ErrorResponse
// @Router /api/v1/otp/codes [get]
func (ctrl *OTPController) GenerateOTPCodes(c *gin.Context) <span class="cov0" title="0">{
        userID := c.MustGet("userID").(string)

        ctrl.logger.Debug("Generating OTP codes via API", "userID", userID)

        codes, err := ctrl.otpUseCase.GenerateOTPCodes(c, userID)
        if err != nil </span><span class="cov0" title="0">{
                ctrl.logger.Error("Failed to generate OTP codes",
                        "userID", userID,
                        "error", err)

                if err == mongo.ErrNoDocuments </span><span class="cov0" title="0">{
                        c.JSON(http.StatusNotFound, dto.ErrorResponse{Error: "User not found"})
                        return
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, dto.ErrorResponse{Error: "Failed to fetch OTPs: " + err.Error()})
                return</span>
        }

        <span class="cov0" title="0">ctrl.logger.Debug("Generated OTP codes via API",
                "userID", userID,
                "codeCount", len(codes))
        c.JSON(http.StatusOK, codes)</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package middleware

import (
        "net/http"

        "github.com/bug-breeder/2fair/server/internal/utils"
        "github.com/gin-gonic/gin"
)

func Authenticate() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                cookie, err := c.Request.Cookie("access_token")
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusUnauthorized, gin.H{"error": "Access token is missing"})
                        c.Abort()
                        return
                }</span>

                <span class="cov0" title="0">accessToken := cookie.Value
                claims, err := utils.ValidateToken(accessToken)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid access token"})
                        c.Abort()
                        return
                }</span>

                <span class="cov0" title="0">c.Set("userID", claims.UserID)
                c.Next()</span>
        }
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package routes

import (
        "os"

        "github.com/bug-breeder/2fair/server/internal/adapter/http/controller"
        "github.com/bug-breeder/2fair/server/internal/adapter/http/middleware"
        "github.com/bug-breeder/2fair/server/internal/infrastructure/configs"
        "github.com/gin-gonic/gin"
        "github.com/gorilla/sessions"
        "github.com/markbates/goth"
        "github.com/markbates/goth/gothic"
        "github.com/markbates/goth/providers/google"
        "github.com/markbates/goth/providers/microsoftonline"
        swaggerFiles "github.com/swaggo/files"
        ginSwagger "github.com/swaggo/gin-swagger"
)

func SetupRoutes(router *gin.Engine, authController *controller.AuthController, otpController *controller.OTPController) <span class="cov0" title="0">{
        // Swagger documentation
        router.GET("/swagger/*any", ginSwagger.WrapHandler(swaggerFiles.Handler))

        // Ensure SESSION_SECRET is set
        gothic.Store = sessions.NewCookieStore([]byte(configs.GetEnv("SESSION_SECRET")))

        redirectURI := os.Getenv("REDIRECT_URI")

        goth.UseProviders(
                google.New(configs.GetEnv("GOOGLE_CLIENT_ID"), configs.GetEnv("GOOGLE_CLIENT_SECRET"), redirectURI+"/api/v1/auth/google/callback"),
                microsoftonline.New(configs.GetEnv("MICROSOFT_CLIENT_ID"), configs.GetEnv("MICROSOFT_CLIENT_SECRET"), redirectURI+"/api/v1/auth/microsoft/callback"),
                // apple.New(configs.GetEnv("APPLE_CLIENT_ID"), configs.GetEnv("APPLE_CLIENT_SECRET"), "http://localhost:8080/api/v1/auth/apple/callback"),
        )

        // API v1 routes
        v1 := router.Group("/api/v1")
        </span><span class="cov0" title="0">{
                // Auth routes
                v1.GET("/auth/:provider", authController.GoogleLogin)
                v1.GET("/auth/:provider/callback", authController.GoogleCallback)
                v1.POST("/auth/refresh", authController.RefreshToken)
                v1.DELETE("/auth/refresh", authController.Logout)

                // Protected routes
                protected := v1.Group("/")
                protected.Use(middleware.Authenticate())
                </span><span class="cov0" title="0">{
                        // OTP routes
                        protected.POST("/otp", otpController.AddOTP)
                        protected.POST("/otp/:id/inactivate", otpController.InactivateOTP)
                        protected.PUT("/otp/:id", otpController.EditOTP)
                        protected.GET("/otp", otpController.ListOTPs)
                        protected.GET("/otp/codes", otpController.GenerateOTPCodes)

                        // User routes
                        protected.GET("/auth/me", authController.GetCurrentUser)
                        protected.GET("/login-history", authController.GetLoginHistory)
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package postgres

import (
        "context"
        "fmt"

        "github.com/jackc/pgx/v5"
        "github.com/jackc/pgx/v5/pgxpool"
)

// PostgresDB represents a PostgreSQL database connection
type PostgresDB struct {
        Pool *pgxpool.Pool
}

// NewPostgresConnection creates a new connection to a PostgreSQL database
func NewPostgresConnection(host, port, user, password, dbname, sslmode string) (*PostgresDB, error) <span class="cov0" title="0">{
        // Create connection string
        connStr := fmt.Sprintf("host=%s port=%s user=%s password=%s dbname=%s sslmode=%s",
                host, port, user, password, dbname, sslmode)

        // Create connection pool
        config, err := pgxpool.ParseConfig(connStr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse connection string: %w", err)
        }</span>

        // Connect to database
        <span class="cov0" title="0">pool, err := pgxpool.NewWithConfig(context.Background(), config)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create connection pool: %w", err)
        }</span>

        // Test the connection
        <span class="cov0" title="0">if err := pool.Ping(context.Background()); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to ping database: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;PostgresDB{Pool: pool}, nil</span>
}

// Close closes the database connection
func (db *PostgresDB) Close() <span class="cov0" title="0">{
        if db.Pool != nil </span><span class="cov0" title="0">{
                db.Pool.Close()
        }</span>
}

// ExecTx executes a function within a database transaction
func (db *PostgresDB) ExecTx(ctx context.Context, fn func(pgx.Tx) error) error <span class="cov0" title="0">{
        tx, err := db.Pool.Begin(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = fn(tx)
        if err != nil </span><span class="cov0" title="0">{
                if rbErr := tx.Rollback(ctx); rbErr != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("tx err: %v, rb err: %v", err, rbErr)
                }</span>
                <span class="cov0" title="0">return err</span>
        }

        <span class="cov0" title="0">return tx.Commit(ctx)</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0

package generated

import (
        "context"

        "github.com/jackc/pgx/v5"
        "github.com/jackc/pgx/v5/pgconn"
)

type DBTX interface {
        Exec(context.Context, string, ...interface{}) (pgconn.CommandTag, error)
        Query(context.Context, string, ...interface{}) (pgx.Rows, error)
        QueryRow(context.Context, string, ...interface{}) pgx.Row
}

func New(db DBTX) *Queries <span class="cov0" title="0">{
        return &amp;Queries{db: db}
}</span>

type Queries struct {
        db DBTX
}

func (q *Queries) WithTx(tx pgx.Tx) *Queries <span class="cov0" title="0">{
        return &amp;Queries{
                db: tx,
        }
}</span>
</pre>
		
		<pre class="file" id="file24" style="display: none">// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: login_events.sql

package generated

import (
        "context"
)

const addLoginEvent = `-- name: AddLoginEvent :one
INSERT INTO login_events (
  user_id,
  ip_address,
  user_agent
) VALUES (
  $1, $2, $3
) RETURNING id, user_id, timestamp, ip_address, user_agent
`

type AddLoginEventParams struct {
        UserID    int32  `json:"user_id"`
        IpAddress string `json:"ip_address"`
        UserAgent string `json:"user_agent"`
}

func (q *Queries) AddLoginEvent(ctx context.Context, arg AddLoginEventParams) (LoginEvent, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, addLoginEvent, arg.UserID, arg.IpAddress, arg.UserAgent)
        var i LoginEvent
        err := row.Scan(
                &amp;i.ID,
                &amp;i.UserID,
                &amp;i.Timestamp,
                &amp;i.IpAddress,
                &amp;i.UserAgent,
        )
        return i, err
}</span>

const getLoginEventByID = `-- name: GetLoginEventByID :one
SELECT id, user_id, timestamp, ip_address, user_agent FROM login_events WHERE id = $1 AND user_id = $2 LIMIT 1
`

type GetLoginEventByIDParams struct {
        ID     int32 `json:"id"`
        UserID int32 `json:"user_id"`
}

func (q *Queries) GetLoginEventByID(ctx context.Context, arg GetLoginEventByIDParams) (LoginEvent, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, getLoginEventByID, arg.ID, arg.UserID)
        var i LoginEvent
        err := row.Scan(
                &amp;i.ID,
                &amp;i.UserID,
                &amp;i.Timestamp,
                &amp;i.IpAddress,
                &amp;i.UserAgent,
        )
        return i, err
}</span>

const listLoginEvents = `-- name: ListLoginEvents :many
SELECT id, user_id, timestamp, ip_address, user_agent FROM login_events WHERE user_id = $1 ORDER BY timestamp DESC LIMIT $2
`

type ListLoginEventsParams struct {
        UserID int32 `json:"user_id"`
        Limit  int32 `json:"limit"`
}

func (q *Queries) ListLoginEvents(ctx context.Context, arg ListLoginEventsParams) ([]LoginEvent, error) <span class="cov0" title="0">{
        rows, err := q.db.Query(ctx, listLoginEvents, arg.UserID, arg.Limit)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        items := []LoginEvent{}
        for rows.Next() </span><span class="cov0" title="0">{
                var i LoginEvent
                if err := rows.Scan(
                        &amp;i.ID,
                        &amp;i.UserID,
                        &amp;i.Timestamp,
                        &amp;i.IpAddress,
                        &amp;i.UserAgent,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const removeLoginEvent = `-- name: RemoveLoginEvent :exec
DELETE FROM login_events WHERE id = $1 AND user_id = $2
`

type RemoveLoginEventParams struct {
        ID     int32 `json:"id"`
        UserID int32 `json:"user_id"`
}

func (q *Queries) RemoveLoginEvent(ctx context.Context, arg RemoveLoginEventParams) error <span class="cov0" title="0">{
        _, err := q.db.Exec(ctx, removeLoginEvent, arg.ID, arg.UserID)
        return err
}</span>
</pre>
		
		<pre class="file" id="file25" style="display: none">// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: otps.sql

package generated

import (
        "context"
)

const addOTP = `-- name: AddOTP :one
INSERT INTO otps (
  user_id,
  issuer,
  label,
  secret,
  algorithm,
  digits,
  period,
  counter,
  method,
  active
) VALUES (
  $1, $2, $3, $4, $5, $6, $7, $8, $9, $10
) RETURNING id, user_id, issuer, label, secret, algorithm, digits, period, counter, method, active, created_at
`

type AddOTPParams struct {
        UserID    int32  `json:"user_id"`
        Issuer    string `json:"issuer"`
        Label     string `json:"label"`
        Secret    string `json:"secret"`
        Algorithm string `json:"algorithm"`
        Digits    int32  `json:"digits"`
        Period    int32  `json:"period"`
        Counter   int32  `json:"counter"`
        Method    string `json:"method"`
        Active    bool   `json:"active"`
}

func (q *Queries) AddOTP(ctx context.Context, arg AddOTPParams) (Otp, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, addOTP,
                arg.UserID,
                arg.Issuer,
                arg.Label,
                arg.Secret,
                arg.Algorithm,
                arg.Digits,
                arg.Period,
                arg.Counter,
                arg.Method,
                arg.Active,
        )
        var i Otp
        err := row.Scan(
                &amp;i.ID,
                &amp;i.UserID,
                &amp;i.Issuer,
                &amp;i.Label,
                &amp;i.Secret,
                &amp;i.Algorithm,
                &amp;i.Digits,
                &amp;i.Period,
                &amp;i.Counter,
                &amp;i.Method,
                &amp;i.Active,
                &amp;i.CreatedAt,
        )
        return i, err
}</span>

const editOTP = `-- name: EditOTP :one
UPDATE otps
SET 
  issuer = $3,
  label = $4,
  secret = $5,
  algorithm = $6,
  digits = $7,
  period = $8,
  counter = $9,
  method = $10
WHERE id = $1 AND user_id = $2
RETURNING id, user_id, issuer, label, secret, algorithm, digits, period, counter, method, active, created_at
`

type EditOTPParams struct {
        ID        int32  `json:"id"`
        UserID    int32  `json:"user_id"`
        Issuer    string `json:"issuer"`
        Label     string `json:"label"`
        Secret    string `json:"secret"`
        Algorithm string `json:"algorithm"`
        Digits    int32  `json:"digits"`
        Period    int32  `json:"period"`
        Counter   int32  `json:"counter"`
        Method    string `json:"method"`
}

func (q *Queries) EditOTP(ctx context.Context, arg EditOTPParams) (Otp, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, editOTP,
                arg.ID,
                arg.UserID,
                arg.Issuer,
                arg.Label,
                arg.Secret,
                arg.Algorithm,
                arg.Digits,
                arg.Period,
                arg.Counter,
                arg.Method,
        )
        var i Otp
        err := row.Scan(
                &amp;i.ID,
                &amp;i.UserID,
                &amp;i.Issuer,
                &amp;i.Label,
                &amp;i.Secret,
                &amp;i.Algorithm,
                &amp;i.Digits,
                &amp;i.Period,
                &amp;i.Counter,
                &amp;i.Method,
                &amp;i.Active,
                &amp;i.CreatedAt,
        )
        return i, err
}</span>

const getOTP = `-- name: GetOTP :one
SELECT id, user_id, issuer, label, secret, algorithm, digits, period, counter, method, active, created_at FROM otps WHERE id = $1 AND user_id = $2 LIMIT 1
`

type GetOTPParams struct {
        ID     int32 `json:"id"`
        UserID int32 `json:"user_id"`
}

func (q *Queries) GetOTP(ctx context.Context, arg GetOTPParams) (Otp, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, getOTP, arg.ID, arg.UserID)
        var i Otp
        err := row.Scan(
                &amp;i.ID,
                &amp;i.UserID,
                &amp;i.Issuer,
                &amp;i.Label,
                &amp;i.Secret,
                &amp;i.Algorithm,
                &amp;i.Digits,
                &amp;i.Period,
                &amp;i.Counter,
                &amp;i.Method,
                &amp;i.Active,
                &amp;i.CreatedAt,
        )
        return i, err
}</span>

const inactivateOTP = `-- name: InactivateOTP :one
UPDATE otps
SET active = false
WHERE id = $1 AND user_id = $2
RETURNING id, user_id, issuer, label, secret, algorithm, digits, period, counter, method, active, created_at
`

type InactivateOTPParams struct {
        ID     int32 `json:"id"`
        UserID int32 `json:"user_id"`
}

func (q *Queries) InactivateOTP(ctx context.Context, arg InactivateOTPParams) (Otp, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, inactivateOTP, arg.ID, arg.UserID)
        var i Otp
        err := row.Scan(
                &amp;i.ID,
                &amp;i.UserID,
                &amp;i.Issuer,
                &amp;i.Label,
                &amp;i.Secret,
                &amp;i.Algorithm,
                &amp;i.Digits,
                &amp;i.Period,
                &amp;i.Counter,
                &amp;i.Method,
                &amp;i.Active,
                &amp;i.CreatedAt,
        )
        return i, err
}</span>

const listOTPs = `-- name: ListOTPs :many
SELECT id, user_id, issuer, label, secret, algorithm, digits, period, counter, method, active, created_at FROM otps WHERE user_id = $1 AND active = true
`

func (q *Queries) ListOTPs(ctx context.Context, userID int32) ([]Otp, error) <span class="cov0" title="0">{
        rows, err := q.db.Query(ctx, listOTPs, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        items := []Otp{}
        for rows.Next() </span><span class="cov0" title="0">{
                var i Otp
                if err := rows.Scan(
                        &amp;i.ID,
                        &amp;i.UserID,
                        &amp;i.Issuer,
                        &amp;i.Label,
                        &amp;i.Secret,
                        &amp;i.Algorithm,
                        &amp;i.Digits,
                        &amp;i.Period,
                        &amp;i.Counter,
                        &amp;i.Method,
                        &amp;i.Active,
                        &amp;i.CreatedAt,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: users.sql

package generated

import (
        "context"
)

const createUser = `-- name: CreateUser :one
INSERT INTO users (
  name,
  email,
  provider,
  provider_id
) VALUES (
  $1, $2, $3, $4
) RETURNING id, name, email, provider, provider_id, created_at
`

type CreateUserParams struct {
        Name       string `json:"name"`
        Email      string `json:"email"`
        Provider   string `json:"provider"`
        ProviderID string `json:"provider_id"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, createUser,
                arg.Name,
                arg.Email,
                arg.Provider,
                arg.ProviderID,
        )
        var i User
        err := row.Scan(
                &amp;i.ID,
                &amp;i.Name,
                &amp;i.Email,
                &amp;i.Provider,
                &amp;i.ProviderID,
                &amp;i.CreatedAt,
        )
        return i, err
}</span>

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, name, email, provider, provider_id, created_at FROM users WHERE email = $1 LIMIT 1
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, getUserByEmail, email)
        var i User
        err := row.Scan(
                &amp;i.ID,
                &amp;i.Name,
                &amp;i.Email,
                &amp;i.Provider,
                &amp;i.ProviderID,
                &amp;i.CreatedAt,
        )
        return i, err
}</span>

const getUserByID = `-- name: GetUserByID :one
SELECT id, name, email, provider, provider_id, created_at FROM users WHERE id = $1 LIMIT 1
`

func (q *Queries) GetUserByID(ctx context.Context, id int32) (User, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, getUserByID, id)
        var i User
        err := row.Scan(
                &amp;i.ID,
                &amp;i.Name,
                &amp;i.Email,
                &amp;i.Provider,
                &amp;i.ProviderID,
                &amp;i.CreatedAt,
        )
        return i, err
}</span>

const updateUser = `-- name: UpdateUser :one
UPDATE users
SET name = $2, email = $3
WHERE id = $1
RETURNING id, name, email, provider, provider_id, created_at
`

type UpdateUserParams struct {
        ID    int32  `json:"id"`
        Name  string `json:"name"`
        Email string `json:"email"`
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) (User, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, updateUser, arg.ID, arg.Name, arg.Email)
        var i User
        err := row.Scan(
                &amp;i.ID,
                &amp;i.Name,
                &amp;i.Email,
                &amp;i.Provider,
                &amp;i.ProviderID,
                &amp;i.CreatedAt,
        )
        return i, err
}</span>
</pre>
		
		<pre class="file" id="file27" style="display: none">package postgres

import (
        "context"
        "errors"
        "fmt"

        "github.com/bug-breeder/2fair/server/internal/adapter/repository"
        "github.com/bug-breeder/2fair/server/internal/adapter/repository/postgres/generated"
        sqlc "github.com/bug-breeder/2fair/server/internal/adapter/repository/postgres/generated"
        "github.com/bug-breeder/2fair/server/internal/domain/models"
        "github.com/jackc/pgx/v5"
)

// Ensure LoginEventRepository implements repository.LoginEventRepository interface
var _ repository.LoginEventRepository = (*LoginEventRepository)(nil)

// LoginEventRepository handles login event data access to PostgreSQL database
type LoginEventRepository struct {
        db      *PostgresDB
        queries *sqlc.Queries
}

// NewPostgresLoginEventRepository creates a new login event repository instance
func NewPostgresLoginEventRepository(db *PostgresDB) *LoginEventRepository <span class="cov0" title="0">{
        return &amp;LoginEventRepository{
                db:      db,
                queries: sqlc.New(db.Pool),
        }
}</span>

// GetLoginEventByID retrieves a login event by its ID
func (r *LoginEventRepository) GetLoginEventByID(ctx context.Context, userID int, sessionID int) (*models.LoginEvent, error) <span class="cov0" title="0">{
        event, err := r.queries.GetLoginEventByID(ctx, generated.GetLoginEventByIDParams{
                ID:     int32(sessionID),
                UserID: int32(userID),
        })
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, pgx.ErrNoRows) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("login event not found with ID: %d for user: %d", sessionID, userID)
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("error finding login event: %w", err)</span>
        }

        <span class="cov0" title="0">return &amp;models.LoginEvent{
                ID:        int(event.ID),
                UserID:    int(event.UserID),
                Timestamp: event.Timestamp,
                IPAddress: event.IpAddress,
                UserAgent: event.UserAgent,
        }, nil</span>
}

// AddLoginEvent adds a new login event
func (r *LoginEventRepository) AddLoginEvent(ctx context.Context, loginEvent *models.LoginEvent) (int, error) <span class="cov0" title="0">{
        result, err := r.queries.AddLoginEvent(ctx, generated.AddLoginEventParams{
                UserID:    int32(loginEvent.UserID),
                IpAddress: loginEvent.IPAddress,
                UserAgent: loginEvent.UserAgent,
        })
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("error adding login event: %w", err)
        }</span>

        <span class="cov0" title="0">return int(result.ID), nil</span>
}

// RemoveLoginEvent removes a login event
func (r *LoginEventRepository) RemoveLoginEvent(ctx context.Context, userID int, sessionID int) error <span class="cov0" title="0">{
        err := r.queries.RemoveLoginEvent(ctx, generated.RemoveLoginEventParams{
                ID:     int32(sessionID),
                UserID: int32(userID),
        })
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, pgx.ErrNoRows) </span><span class="cov0" title="0">{
                        return fmt.Errorf("login event not found with ID: %d for user: %d", sessionID, userID)
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("error removing login event: %w", err)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// ListLoginEvents lists login events for a user with pagination
func (r *LoginEventRepository) ListLoginEvents(ctx context.Context, userID int, limit int) ([]models.LoginEvent, error) <span class="cov0" title="0">{
        events, err := r.queries.ListLoginEvents(ctx, generated.ListLoginEventsParams{
                UserID: int32(userID),
                Limit:  int32(limit),
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error listing login events: %w", err)
        }</span>

        <span class="cov0" title="0">result := make([]models.LoginEvent, len(events))
        for i, event := range events </span><span class="cov0" title="0">{
                result[i] = models.LoginEvent{
                        ID:        int(event.ID),
                        UserID:    int(event.UserID),
                        Timestamp: event.Timestamp,
                        IPAddress: event.IpAddress,
                        UserAgent: event.UserAgent,
                }
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package postgres

import (
        "context"
        "fmt"

        "github.com/bug-breeder/2fair/server/internal/adapter/repository"
        sqlc "github.com/bug-breeder/2fair/server/internal/adapter/repository/postgres/generated"
        "github.com/bug-breeder/2fair/server/internal/domain/models"
)

// Ensure OTPRepository implements repository.OTPRepository interface
var _ repository.OTPRepository = (*OTPRepository)(nil)

// OTPRepository handles OTP data access to PostgreSQL database
type OTPRepository struct {
        db      *PostgresDB
        queries *sqlc.Queries
}

// NewPostgresOTPRepository creates a new OTP repository instance
func NewPostgresOTPRepository(db *PostgresDB) *OTPRepository <span class="cov0" title="0">{
        return &amp;OTPRepository{
                db:      db,
                queries: sqlc.New(db.Pool),
        }
}</span>

// AddOTP adds a new OTP for a user
func (r *OTPRepository) AddOTP(ctx context.Context, userID int, otp *models.OTP) error <span class="cov0" title="0">{
        params := sqlc.AddOTPParams{
                UserID:    int32(userID),
                Issuer:    otp.Issuer,
                Label:     otp.Label,
                Secret:    otp.Secret,
                Algorithm: otp.Algorithm,
                Digits:    int32(otp.Digits),
                Period:    int32(otp.Period),
                Counter:   int32(otp.Counter),
                Method:    otp.Method,
                Active:    otp.Active,
        }

        _, err := r.queries.AddOTP(ctx, params)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error adding OTP: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// InactivateOTP marks an OTP as inactive
func (r *OTPRepository) InactivateOTP(ctx context.Context, userID, otpID int) error <span class="cov0" title="0">{
        params := sqlc.InactivateOTPParams{
                ID:     int32(otpID),
                UserID: int32(userID),
        }

        _, err := r.queries.InactivateOTP(ctx, params)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error inactivating OTP: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// EditOTP updates an existing OTP
func (r *OTPRepository) EditOTP(ctx context.Context, userID, otpID int, otp *models.OTP) error <span class="cov0" title="0">{
        fmt.Printf("Repository EditOTP called - userID: %d, otpID: %d, issuer: %s, label: %s\n",
                userID, otpID, otp.Issuer, otp.Label)

        // First, get the existing OTP to merge changes
        existingOTP, err := r.queries.GetOTP(ctx, sqlc.GetOTPParams{
                ID:     int32(otpID),
                UserID: int32(userID),
        })
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Repository EditOTP - failed to get existing OTP: %v\n", err)
                return fmt.Errorf("error getting existing OTP: %w", err)
        }</span>

        // Merge changes - only update fields that are provided (non-empty/non-zero)
        <span class="cov0" title="0">updatedOTP := existingOTP

        if otp.Issuer != "" </span><span class="cov0" title="0">{
                updatedOTP.Issuer = otp.Issuer
        }</span>
        <span class="cov0" title="0">if otp.Label != "" </span><span class="cov0" title="0">{
                updatedOTP.Label = otp.Label
        }</span>
        <span class="cov0" title="0">if otp.Secret != "" </span><span class="cov0" title="0">{
                updatedOTP.Secret = otp.Secret
        }</span>
        <span class="cov0" title="0">if otp.Algorithm != "" </span><span class="cov0" title="0">{
                updatedOTP.Algorithm = otp.Algorithm
        }</span>
        <span class="cov0" title="0">if otp.Digits != 0 </span><span class="cov0" title="0">{
                updatedOTP.Digits = int32(otp.Digits)
        }</span>
        <span class="cov0" title="0">if otp.Period != 0 </span><span class="cov0" title="0">{
                updatedOTP.Period = int32(otp.Period)
        }</span>
        <span class="cov0" title="0">if otp.Counter != 0 </span><span class="cov0" title="0">{
                updatedOTP.Counter = int32(otp.Counter)
        }</span>
        <span class="cov0" title="0">if otp.Method != "" </span><span class="cov0" title="0">{
                updatedOTP.Method = otp.Method
        }</span>

        <span class="cov0" title="0">params := sqlc.EditOTPParams{
                ID:        int32(otpID),
                UserID:    int32(userID),
                Issuer:    updatedOTP.Issuer,
                Label:     updatedOTP.Label,
                Secret:    updatedOTP.Secret,
                Algorithm: updatedOTP.Algorithm,
                Digits:    updatedOTP.Digits,
                Period:    updatedOTP.Period,
                Counter:   updatedOTP.Counter,
                Method:    updatedOTP.Method,
        }

        fmt.Printf("Repository EditOTP merged params - ID: %d, UserID: %d, Issuer: %s, Label: %s, Algorithm: %s, Digits: %d, Period: %d, Method: %s\n",
                params.ID, params.UserID, params.Issuer, params.Label, params.Algorithm, params.Digits, params.Period, params.Method)

        result, err := r.queries.EditOTP(ctx, params)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Repository EditOTP SQL error: %v\n", err)
                return fmt.Errorf("error updating OTP: %w", err)
        }</span>

        <span class="cov0" title="0">fmt.Printf("Repository EditOTP success - updated OTP ID: %d, new issuer: %s\n", result.ID, result.Issuer)
        return nil</span>
}

// ListOTPs retrieves all active OTPs for a user
func (r *OTPRepository) ListOTPs(ctx context.Context, userID int) ([]models.OTP, error) <span class="cov0" title="0">{
        dbOTPs, err := r.queries.ListOTPs(ctx, int32(userID))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error listing OTPs: %w", err)
        }</span>

        <span class="cov0" title="0">otps := make([]models.OTP, len(dbOTPs))
        for i, dbOTP := range dbOTPs </span><span class="cov0" title="0">{
                otps[i] = models.OTP{
                        ID:        int(dbOTP.ID),
                        UserID:    int(dbOTP.UserID),
                        Issuer:    dbOTP.Issuer,
                        Label:     dbOTP.Label,
                        Secret:    dbOTP.Secret,
                        Algorithm: dbOTP.Algorithm,
                        Digits:    int(dbOTP.Digits),
                        Counter:   int(dbOTP.Counter),
                        Period:    int(dbOTP.Period),
                        Method:    dbOTP.Method,
                        Active:    dbOTP.Active,
                        CreatedAt: dbOTP.CreatedAt,
                }
        }</span>

        <span class="cov0" title="0">return otps, nil</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package postgres

import (
        "context"
        "errors"
        "fmt"

        "github.com/bug-breeder/2fair/server/internal/adapter/repository"
        sqlc "github.com/bug-breeder/2fair/server/internal/adapter/repository/postgres/generated"
        "github.com/bug-breeder/2fair/server/internal/domain/models"
        "github.com/jackc/pgx/v5"
)

// Ensure UserRepository implements repository.UserRepository interface
var _ repository.UserRepository = (*UserRepository)(nil)

// UserRepository handles user data access to PostgreSQL database
type UserRepository struct {
        db      *PostgresDB
        queries *sqlc.Queries
}

// NewPostgresUserRepository creates a new user repository instance
func NewPostgresUserRepository(db *PostgresDB) *UserRepository <span class="cov0" title="0">{
        return &amp;UserRepository{
                db:      db,
                queries: sqlc.New(db.Pool),
        }
}</span>

// FindByID finds a user by ID
func (r *UserRepository) FindByID(ctx context.Context, id int) (*models.User, error) <span class="cov0" title="0">{
        user, err := r.queries.GetUserByID(ctx, int32(id))
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, pgx.ErrNoRows) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("user not found with ID: %d", id)
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("error finding user by ID: %w", err)</span>
        }

        <span class="cov0" title="0">return &amp;models.User{
                ID:         int(user.ID),
                Name:       user.Name,
                Email:      user.Email,
                Provider:   user.Provider,
                ProviderID: user.ProviderID,
                CreatedAt:  user.CreatedAt,
        }, nil</span>
}

// FindByEmail finds a user by email
func (r *UserRepository) FindByEmail(ctx context.Context, email string) (*models.User, error) <span class="cov0" title="0">{
        user, err := r.queries.GetUserByEmail(ctx, email)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, pgx.ErrNoRows) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("user not found with email: %s", email)
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("error finding user by email: %w", err)</span>
        }

        <span class="cov0" title="0">return &amp;models.User{
                ID:         int(user.ID),
                Name:       user.Name,
                Email:      user.Email,
                Provider:   user.Provider,
                ProviderID: user.ProviderID,
                CreatedAt:  user.CreatedAt,
        }, nil</span>
}

// CreateUser creates a new user
func (r *UserRepository) CreateUser(ctx context.Context, user *models.User) (int, error) <span class="cov0" title="0">{
        params := sqlc.CreateUserParams{
                Name:       user.Name,
                Email:      user.Email,
                Provider:   user.Provider,
                ProviderID: user.ProviderID,
        }

        result, err := r.queries.CreateUser(ctx, params)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("error creating user: %w", err)
        }</span>

        <span class="cov0" title="0">return int(result.ID), nil</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package entities

import (
        "time"

        "github.com/google/uuid"
)

// DeviceSession represents a user session on a specific device
type DeviceSession struct {
        ID             uuid.UUID `json:"id" db:"id"`
        UserID         uuid.UUID `json:"user_id" db:"user_id"`
        SessionToken   string    `json:"session_token" db:"session_token"`
        DeviceInfo     string    `json:"device_info" db:"device_info"`
        IPAddress      string    `json:"ip_address" db:"ip_address"`
        UserAgent      string    `json:"user_agent" db:"user_agent"`
        IsActive       bool      `json:"is_active" db:"is_active"`
        LastActivityAt time.Time `json:"last_activity_at" db:"last_activity_at"`
        ExpiresAt      time.Time `json:"expires_at" db:"expires_at"`
        CreatedAt      time.Time `json:"created_at" db:"created_at"`
        UpdatedAt      time.Time `json:"updated_at" db:"updated_at"`
}

// IsExpired checks if the session has expired
func (ds *DeviceSession) IsExpired() bool <span class="cov0" title="0">{
        return time.Now().After(ds.ExpiresAt)
}</span>

// IsValid checks if the session is valid (active and not expired)
func (ds *DeviceSession) IsValid() bool <span class="cov0" title="0">{
        return ds.IsActive &amp;&amp; !ds.IsExpired()
}</span>

// Validate performs basic validation on the device session
func (ds *DeviceSession) Validate() error <span class="cov0" title="0">{
        if ds.UserID == uuid.Nil </span><span class="cov0" title="0">{
                return ErrInvalidDevice
        }</span>

        <span class="cov0" title="0">if ds.SessionToken == "" </span><span class="cov0" title="0">{
                return ErrInvalidDevice
        }</span>

        <span class="cov0" title="0">if ds.DeviceInfo == "" </span><span class="cov0" title="0">{
                return ErrInvalidDevice
        }</span>

        <span class="cov0" title="0">if ds.ExpiresAt.Before(time.Now()) </span><span class="cov0" title="0">{
                return ErrDeviceExpired
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// UpdateActivity updates the last activity timestamp
func (ds *DeviceSession) UpdateActivity() <span class="cov0" title="0">{
        ds.LastActivityAt = time.Now()
        ds.UpdatedAt = time.Now()
}</span>

// Deactivate marks the session as inactive
func (ds *DeviceSession) Deactivate() <span class="cov0" title="0">{
        ds.IsActive = false
        ds.UpdatedAt = time.Now()
}</span>
</pre>
		
		<pre class="file" id="file31" style="display: none">package entities

import (
        "time"

        "github.com/google/uuid"
)

// UserEncryptionKey represents a wrapped Data Encryption Key (DEK) for a user
type UserEncryptionKey struct {
        ID         uuid.UUID `json:"id" db:"id"`
        UserID     uuid.UUID `json:"userId" db:"user_id"`
        KeyVersion int       `json:"keyVersion" db:"key_version"`
        WrappedDEK []byte    `json:"wrappedDEK" db:"wrapped_dek"` // DEK encrypted with KEK from WebAuthn PRF
        Salt       []byte    `json:"salt" db:"salt"`              // Salt used in HKDF for KEK-&gt;DEK derivation
        CreatedAt  time.Time `json:"createdAt" db:"created_at"`
        IsActive   bool      `json:"isActive" db:"is_active"`
}

// NewUserEncryptionKey creates a new user encryption key
func NewUserEncryptionKey(userID uuid.UUID, keyVersion int, wrappedDEK, salt []byte) *UserEncryptionKey <span class="cov0" title="0">{
        return &amp;UserEncryptionKey{
                ID:         uuid.New(),
                UserID:     userID,
                KeyVersion: keyVersion,
                WrappedDEK: wrappedDEK,
                Salt:       salt,
                CreatedAt:  time.Now(),
                IsActive:   true,
        }
}</span>

// Validate validates the encryption key entity
func (k *UserEncryptionKey) Validate() error <span class="cov0" title="0">{
        if k.UserID == uuid.Nil </span><span class="cov0" title="0">{
                return ErrInvalidEncryptionKey
        }</span>
        <span class="cov0" title="0">if k.KeyVersion &lt; 1 </span><span class="cov0" title="0">{
                return ErrInvalidEncryptionKey
        }</span>
        <span class="cov0" title="0">if len(k.WrappedDEK) == 0 </span><span class="cov0" title="0">{
                return ErrInvalidEncryptionKey
        }</span>
        <span class="cov0" title="0">if len(k.Salt) == 0 </span><span class="cov0" title="0">{
                return ErrInvalidEncryptionKey
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Deactivate marks the encryption key as inactive
func (k *UserEncryptionKey) Deactivate() <span class="cov0" title="0">{
        k.IsActive = false
}</span>

// Activate marks the encryption key as active
func (k *UserEncryptionKey) Activate() <span class="cov0" title="0">{
        k.IsActive = true
}</span>
</pre>
		
		<pre class="file" id="file32" style="display: none">package entities

import (
        "database/sql/driver"
        "strings"
        "time"

        "github.com/google/uuid"
        "github.com/lib/pq"
)

// EncryptedTOTPSeed represents an encrypted TOTP seed with searchable metadata
type EncryptedTOTPSeed struct {
        ID         uuid.UUID `json:"id" db:"id"`
        UserID     uuid.UUID `json:"userId" db:"user_id"`
        KeyVersion int       `json:"keyVersion" db:"key_version"`

        // Encrypted payload (AES-GCM)
        Ciphertext []byte `json:"ciphertext" db:"ciphertext"` // AES-GCM encrypted TOTP seed + metadata
        IV         []byte `json:"iv" db:"iv"`                 // AES-GCM initialization vector (96 bits)
        AuthTag    []byte `json:"authTag" db:"auth_tag"`      // AES-GCM authentication tag

        // Searchable metadata (never encrypted for UX)
        Issuer      string         `json:"issuer" db:"issuer" validate:"required,max=255"`
        AccountName string         `json:"accountName" db:"account_name" validate:"required,max=255"`
        IconURL     *string        `json:"iconUrl,omitempty" db:"icon_url"`
        Tags        pq.StringArray `json:"tags" db:"tags"`

        // Timestamps and sync
        CreatedAt time.Time `json:"createdAt" db:"created_at"`
        UpdatedAt time.Time `json:"updatedAt" db:"updated_at"`
        SyncedAt  time.Time `json:"syncedAt" db:"synced_at"`
}

// EncryptedData represents the encrypted components of a TOTP seed
type EncryptedData struct {
        Ciphertext []byte `json:"ciphertext"`
        IV         []byte `json:"iv"`
        AuthTag    []byte `json:"authTag"`
}

// NewEncryptedTOTPSeed creates a new encrypted TOTP seed
func NewEncryptedTOTPSeed(userID uuid.UUID, keyVersion int, issuer, accountName string, encryptedData EncryptedData) *EncryptedTOTPSeed <span class="cov0" title="0">{
        now := time.Now()
        return &amp;EncryptedTOTPSeed{
                ID:          uuid.New(),
                UserID:      userID,
                KeyVersion:  keyVersion,
                Ciphertext:  encryptedData.Ciphertext,
                IV:          encryptedData.IV,
                AuthTag:     encryptedData.AuthTag,
                Issuer:      issuer,
                AccountName: accountName,
                Tags:        pq.StringArray{},
                CreatedAt:   now,
                UpdatedAt:   now,
                SyncedAt:    now,
        }
}</span>

// Validate validates the encrypted TOTP seed entity
func (e *EncryptedTOTPSeed) Validate() error <span class="cov0" title="0">{
        if e.UserID == uuid.Nil </span><span class="cov0" title="0">{
                return ErrInvalidTOTPSeed
        }</span>
        <span class="cov0" title="0">if e.KeyVersion &lt; 1 </span><span class="cov0" title="0">{
                return ErrInvalidTOTPSeed
        }</span>
        <span class="cov0" title="0">if len(e.Ciphertext) == 0 </span><span class="cov0" title="0">{
                return ErrInvalidTOTPSeed
        }</span>
        <span class="cov0" title="0">if len(e.IV) != 12 </span><span class="cov0" title="0">{ // AES-GCM IV should be 96 bits (12 bytes)
                return ErrInvalidTOTPSeed
        }</span>
        <span class="cov0" title="0">if len(e.AuthTag) != 16 </span><span class="cov0" title="0">{ // AES-GCM auth tag should be 128 bits (16 bytes)
                return ErrInvalidTOTPSeed
        }</span>
        <span class="cov0" title="0">if strings.TrimSpace(e.Issuer) == "" </span><span class="cov0" title="0">{
                return ErrInvalidTOTPSeed
        }</span>
        <span class="cov0" title="0">if strings.TrimSpace(e.AccountName) == "" </span><span class="cov0" title="0">{
                return ErrInvalidTOTPSeed
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// UpdateEncryption updates the encrypted data for the TOTP seed
func (e *EncryptedTOTPSeed) UpdateEncryption(encryptedData EncryptedData, keyVersion int) <span class="cov0" title="0">{
        e.Ciphertext = encryptedData.Ciphertext
        e.IV = encryptedData.IV
        e.AuthTag = encryptedData.AuthTag
        e.KeyVersion = keyVersion
        e.UpdatedAt = time.Now()
}</span>

// UpdateMetadata updates the searchable metadata
func (e *EncryptedTOTPSeed) UpdateMetadata(issuer, accountName string, iconURL *string, tags []string) <span class="cov0" title="0">{
        e.Issuer = issuer
        e.AccountName = accountName
        e.IconURL = iconURL
        e.Tags = pq.StringArray(tags)
        e.UpdatedAt = time.Now()
}</span>

// GetEncryptedData returns the encrypted data components
func (e *EncryptedTOTPSeed) GetEncryptedData() EncryptedData <span class="cov0" title="0">{
        return EncryptedData{
                Ciphertext: e.Ciphertext,
                IV:         e.IV,
                AuthTag:    e.AuthTag,
        }
}</span>

// AddTag adds a tag to the TOTP seed
func (e *EncryptedTOTPSeed) AddTag(tag string) <span class="cov0" title="0">{
        tag = strings.TrimSpace(tag)
        if tag == "" </span><span class="cov0" title="0">{
                return
        }</span>

        // Check if tag already exists
        <span class="cov0" title="0">for _, existingTag := range e.Tags </span><span class="cov0" title="0">{
                if existingTag == tag </span><span class="cov0" title="0">{
                        return
                }</span>
        }

        <span class="cov0" title="0">e.Tags = append(e.Tags, tag)
        e.UpdatedAt = time.Now()</span>
}

// RemoveTag removes a tag from the TOTP seed
func (e *EncryptedTOTPSeed) RemoveTag(tag string) <span class="cov0" title="0">{
        for i, existingTag := range e.Tags </span><span class="cov0" title="0">{
                if existingTag == tag </span><span class="cov0" title="0">{
                        e.Tags = append(e.Tags[:i], e.Tags[i+1:]...)
                        e.UpdatedAt = time.Now()
                        break</span>
                }
        }
}

// SetTags sets all tags for the TOTP seed
func (e *EncryptedTOTPSeed) SetTags(tags []string) <span class="cov0" title="0">{
        // Clean and deduplicate tags
        cleanTags := make([]string, 0, len(tags))
        seen := make(map[string]bool)

        for _, tag := range tags </span><span class="cov0" title="0">{
                tag = strings.TrimSpace(tag)
                if tag != "" &amp;&amp; !seen[tag] </span><span class="cov0" title="0">{
                        cleanTags = append(cleanTags, tag)
                        seen[tag] = true
                }</span>
        }

        <span class="cov0" title="0">e.Tags = pq.StringArray(cleanTags)
        e.UpdatedAt = time.Now()</span>
}

// MarkSynced updates the synced timestamp
func (e *EncryptedTOTPSeed) MarkSynced() <span class="cov0" title="0">{
        e.SyncedAt = time.Now()
}</span>

// HasTag checks if the TOTP seed has a specific tag
func (e *EncryptedTOTPSeed) HasTag(tag string) bool <span class="cov0" title="0">{
        for _, existingTag := range e.Tags </span><span class="cov0" title="0">{
                if existingTag == tag </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// MatchesQuery checks if the TOTP seed matches a search query
func (e *EncryptedTOTPSeed) MatchesQuery(query string) bool <span class="cov0" title="0">{
        query = strings.ToLower(strings.TrimSpace(query))
        if query == "" </span><span class="cov0" title="0">{
                return true
        }</span>

        // Search in issuer
        <span class="cov0" title="0">if strings.Contains(strings.ToLower(e.Issuer), query) </span><span class="cov0" title="0">{
                return true
        }</span>

        // Search in account name
        <span class="cov0" title="0">if strings.Contains(strings.ToLower(e.AccountName), query) </span><span class="cov0" title="0">{
                return true
        }</span>

        // Search in tags
        <span class="cov0" title="0">for _, tag := range e.Tags </span><span class="cov0" title="0">{
                if strings.Contains(strings.ToLower(tag), query) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}

// Ensure pq.StringArray implements the necessary interfaces
var _ driver.Valuer = (*pq.StringArray)(nil)
</pre>
		
		<pre class="file" id="file33" style="display: none">package entities

import (
        "time"

        "github.com/google/uuid"
)

// User represents a user in the system
type User struct {
        ID          uuid.UUID  `json:"id" db:"id"`
        Username    string     `json:"username" db:"username" validate:"required,min=3,max=255"`
        Email       string     `json:"email" db:"email" validate:"required,email,max=255"`
        DisplayName string     `json:"displayName" db:"display_name" validate:"required,min=1,max=255"`
        CreatedAt   time.Time  `json:"createdAt" db:"created_at"`
        UpdatedAt   time.Time  `json:"updatedAt" db:"updated_at"`
        LastLoginAt *time.Time `json:"lastLoginAt,omitempty" db:"last_login_at"`
        IsActive    bool       `json:"isActive" db:"is_active"`
}

// NewUser creates a new user with default values
func NewUser(username, email, displayName string) *User <span class="cov8" title="1">{
        return &amp;User{
                ID:          uuid.New(),
                Username:    username,
                Email:       email,
                DisplayName: displayName,
                CreatedAt:   time.Now(),
                UpdatedAt:   time.Now(),
                IsActive:    true,
        }
}</span>

// Validate validates the user entity
func (u *User) Validate() error <span class="cov8" title="1">{
        // Basic validation - in production, use a proper validation library
        if u.Username == "" </span><span class="cov8" title="1">{
                return ErrInvalidUsername
        }</span>
        <span class="cov8" title="1">if u.Email == "" </span><span class="cov8" title="1">{
                return ErrInvalidEmail
        }</span>
        <span class="cov8" title="1">if u.DisplayName == "" </span><span class="cov8" title="1">{
                return ErrInvalidDisplayName
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// UpdateLastLogin updates the last login timestamp
func (u *User) UpdateLastLogin() <span class="cov8" title="1">{
        now := time.Now()
        u.LastLoginAt = &amp;now
        u.UpdatedAt = now
}</span>

// Deactivate deactivates the user account
func (u *User) Deactivate() <span class="cov8" title="1">{
        u.IsActive = false
        u.UpdatedAt = time.Now()
}</span>
</pre>
		
		<pre class="file" id="file34" style="display: none">package entities

import (
        "time"

        "github.com/google/uuid"
)

// WebAuthnCredential represents a WebAuthn credential for a user
type WebAuthnCredential struct {
        ID             uuid.UUID  `json:"id" db:"id"`
        UserID         uuid.UUID  `json:"userId" db:"user_id"`
        CredentialID   []byte     `json:"credentialId" db:"credential_id"`
        PublicKey      []byte     `json:"publicKey" db:"public_key"`
        AAGUID         *uuid.UUID `json:"aaguid,omitempty" db:"aaguid"`
        CloneWarning   bool       `json:"cloneWarning" db:"clone_warning"`
        Attachment     string     `json:"attachment,omitempty" db:"attachment"` // platform, cross-platform
        Transport      []string   `json:"transport,omitempty" db:"transport"`   // usb, nfc, ble, internal
        BackupEligible bool       `json:"backupEligible" db:"backup_eligible"`
        BackupState    bool       `json:"backupState" db:"backup_state"`
        SignCount      uint64     `json:"signCount" db:"sign_count"`
        CreatedAt      time.Time  `json:"createdAt" db:"created_at"`
        LastUsedAt     *time.Time `json:"lastUsedAt,omitempty" db:"last_used_at"`
}

// NewWebAuthnCredential creates a new WebAuthn credential
func NewWebAuthnCredential(userID uuid.UUID, credentialID, publicKey []byte) *WebAuthnCredential <span class="cov8" title="1">{
        return &amp;WebAuthnCredential{
                ID:           uuid.New(),
                UserID:       userID,
                CredentialID: credentialID,
                PublicKey:    publicKey,
                CreatedAt:    time.Now(),
                SignCount:    0,
        }
}</span>

// Validate validates the WebAuthn credential
func (w *WebAuthnCredential) Validate() error <span class="cov8" title="1">{
        if w.UserID == uuid.Nil </span><span class="cov8" title="1">{
                return ErrInvalidCredential
        }</span>
        <span class="cov8" title="1">if len(w.CredentialID) == 0 </span><span class="cov8" title="1">{
                return ErrInvalidCredential
        }</span>
        <span class="cov8" title="1">if len(w.PublicKey) == 0 </span><span class="cov8" title="1">{
                return ErrInvalidCredential
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// UpdateSignCount updates the sign count and last used timestamp
func (w *WebAuthnCredential) UpdateSignCount(newCount uint64) <span class="cov8" title="1">{
        // Check for clone warning (sign count decreased)
        if newCount &lt; w.SignCount </span><span class="cov8" title="1">{
                w.CloneWarning = true
        }</span>

        <span class="cov8" title="1">w.SignCount = newCount
        now := time.Now()
        w.LastUsedAt = &amp;now</span>
}

// UpdateUsage updates the last used timestamp
func (w *WebAuthnCredential) UpdateUsage() <span class="cov8" title="1">{
        now := time.Now()
        w.LastUsedAt = &amp;now
}</span>

// SetTransport sets the transport methods for the credential
func (w *WebAuthnCredential) SetTransport(transport []string) <span class="cov8" title="1">{
        w.Transport = transport
}</span>

// SetAttachment sets the attachment type for the credential
func (w *WebAuthnCredential) SetAttachment(attachment string) <span class="cov8" title="1">{
        w.Attachment = attachment
}</span>

// SetBackupFlags sets the backup eligible and state flags
func (w *WebAuthnCredential) SetBackupFlags(eligible, state bool) <span class="cov8" title="1">{
        w.BackupEligible = eligible
        w.BackupState = state
}</span>
</pre>
		
		<pre class="file" id="file35" style="display: none">package models

import (
        "encoding/base32"
        "fmt"
        "regexp"
        "strings"
        "time"
)

type OTP struct {
        ID        int       `json:"id" db:"id"`
        UserID    int       `json:"user_id" db:"user_id"`
        Issuer    string    `json:"issuer" db:"issuer"`
        Label     string    `json:"label" db:"label"`
        Secret    string    `json:"secret" db:"secret"`
        Algorithm string    `json:"algorithm" db:"algorithm"`
        Digits    int       `json:"digits" db:"digits"`
        Period    int       `json:"period" db:"period"`
        Counter   int       `json:"counter" db:"counter"`
        Method    string    `json:"method" db:"method"`
        Active    bool      `json:"active" db:"active"`
        CreatedAt time.Time `json:"created_at" db:"created_at"`
}

// ValidateAndNormalize validates and normalizes OTP parameters
func (o *OTP) ValidateAndNormalize() error <span class="cov0" title="0">{
        // Validate and normalize secret
        if err := o.validateAndNormalizeSecret(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid secret: %w", err)
        }</span>

        // Validate issuer
        <span class="cov0" title="0">if err := o.validateIssuer(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid issuer: %w", err)
        }</span>

        // Validate label
        <span class="cov0" title="0">if err := o.validateLabel(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid label: %w", err)
        }</span>

        // Validate algorithm
        <span class="cov0" title="0">if err := o.validateAlgorithm(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid algorithm: %w", err)
        }</span>

        // Validate digits
        <span class="cov0" title="0">if err := o.validateDigits(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid digits: %w", err)
        }</span>

        // Validate period
        <span class="cov0" title="0">if err := o.validatePeriod(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid period: %w", err)
        }</span>

        // Validate method
        <span class="cov0" title="0">if err := o.validateMethod(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid method: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ValidateForEdit validates OTP parameters for edit operations
// Only validates non-empty fields, allowing partial updates
func (o *OTP) ValidateForEdit() error <span class="cov0" title="0">{
        // Only validate secret if it's being updated (not empty)
        if o.Secret != "" </span><span class="cov0" title="0">{
                if err := o.validateAndNormalizeSecret(); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid secret: %w", err)
                }</span>
        }

        // Only validate issuer if it's being updated (not empty)
        <span class="cov0" title="0">if o.Issuer != "" </span><span class="cov0" title="0">{
                if err := o.validateIssuer(); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid issuer: %w", err)
                }</span>
        }

        // Only validate label if it's being updated (not empty)
        <span class="cov0" title="0">if o.Label != "" </span><span class="cov0" title="0">{
                if err := o.validateLabel(); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid label: %w", err)
                }</span>
        }

        // Only validate algorithm if it's being updated (not empty)
        <span class="cov0" title="0">if o.Algorithm != "" </span><span class="cov0" title="0">{
                if err := o.validateAlgorithm(); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid algorithm: %w", err)
                }</span>
        }

        // Only validate digits if it's being updated (not zero)
        <span class="cov0" title="0">if o.Digits != 0 </span><span class="cov0" title="0">{
                if err := o.validateDigits(); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid digits: %w", err)
                }</span>
        }

        // Only validate period if it's being updated (not zero)
        <span class="cov0" title="0">if o.Period != 0 </span><span class="cov0" title="0">{
                if err := o.validatePeriod(); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid period: %w", err)
                }</span>
        }

        // Only validate method if it's being updated (not empty)
        <span class="cov0" title="0">if o.Method != "" </span><span class="cov0" title="0">{
                if err := o.validateMethod(); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid method: %w", err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// validateAndNormalizeSecret validates and normalizes the TOTP secret
func (o *OTP) validateAndNormalizeSecret() error <span class="cov0" title="0">{
        if o.Secret == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("secret cannot be empty")
        }</span>

        // Remove spaces and convert to uppercase
        <span class="cov0" title="0">normalized := strings.ToUpper(strings.ReplaceAll(o.Secret, " ", ""))

        // Remove common separators that users might include
        normalized = strings.ReplaceAll(normalized, "-", "")
        normalized = strings.ReplaceAll(normalized, "_", "")

        // Validate base32 format
        if !isValidBase32(normalized) </span><span class="cov0" title="0">{
                return fmt.Errorf("secret must be valid base32 encoded string (A-Z, 2-7)")
        }</span>

        // Try to decode to ensure it's valid
        <span class="cov0" title="0">_, err := base32.StdEncoding.DecodeString(normalized)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("secret is not valid base32: %w", err)
        }</span>

        // Check minimum length (should be at least 80 bits / 16 base32 chars for security)
        <span class="cov0" title="0">if len(normalized) &lt; 16 </span><span class="cov0" title="0">{
                return fmt.Errorf("secret too short, minimum 16 characters required for security")
        }</span>

        // Check maximum length (reasonable upper bound)
        <span class="cov0" title="0">if len(normalized) &gt; 128 </span><span class="cov0" title="0">{
                return fmt.Errorf("secret too long, maximum 128 characters allowed")
        }</span>

        <span class="cov0" title="0">o.Secret = normalized
        return nil</span>
}

// validateIssuer validates the issuer field
func (o *OTP) validateIssuer() error <span class="cov0" title="0">{
        if o.Issuer == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("issuer cannot be empty")
        }</span>

        <span class="cov0" title="0">if len(o.Issuer) &gt; 100 </span><span class="cov0" title="0">{
                return fmt.Errorf("issuer too long, maximum 100 characters allowed")
        }</span>

        // Check for invalid characters
        <span class="cov0" title="0">if strings.ContainsAny(o.Issuer, ":;") </span><span class="cov0" title="0">{
                return fmt.Errorf("issuer cannot contain ':' or ';' characters")
        }</span>

        // Trim whitespace
        <span class="cov0" title="0">o.Issuer = strings.TrimSpace(o.Issuer)
        return nil</span>
}

// validateLabel validates the label field
func (o *OTP) validateLabel() error <span class="cov0" title="0">{
        if o.Label == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("label cannot be empty")
        }</span>

        <span class="cov0" title="0">if len(o.Label) &gt; 100 </span><span class="cov0" title="0">{
                return fmt.Errorf("label too long, maximum 100 characters allowed")
        }</span>

        // Check for invalid characters
        <span class="cov0" title="0">if strings.ContainsAny(o.Label, ":;") </span><span class="cov0" title="0">{
                return fmt.Errorf("label cannot contain ':' or ';' characters")
        }</span>

        // Trim whitespace
        <span class="cov0" title="0">o.Label = strings.TrimSpace(o.Label)
        return nil</span>
}

// validateAlgorithm validates the algorithm field
func (o *OTP) validateAlgorithm() error <span class="cov0" title="0">{
        validAlgorithms := map[string]bool{
                "SHA1":   true,
                "SHA256": true,
                "SHA512": true,
        }

        algorithm := strings.ToUpper(o.Algorithm)
        if !validAlgorithms[algorithm] </span><span class="cov0" title="0">{
                return fmt.Errorf("algorithm must be one of: SHA1, SHA256, SHA512")
        }</span>

        <span class="cov0" title="0">o.Algorithm = algorithm
        return nil</span>
}

// validateDigits validates the digits field
func (o *OTP) validateDigits() error <span class="cov0" title="0">{
        if o.Digits &lt; 6 || o.Digits &gt; 8 </span><span class="cov0" title="0">{
                return fmt.Errorf("digits must be between 6 and 8")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// validatePeriod validates the period field for TOTP
func (o *OTP) validatePeriod() error <span class="cov0" title="0">{
        if o.Method == "TOTP" </span><span class="cov0" title="0">{
                if o.Period &lt; 15 || o.Period &gt; 300 </span><span class="cov0" title="0">{
                        return fmt.Errorf("period must be between 15 and 300 seconds")
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// validateMethod validates the method field
func (o *OTP) validateMethod() error <span class="cov0" title="0">{
        validMethods := map[string]bool{
                "TOTP": true,
                "HOTP": true,
        }

        method := strings.ToUpper(o.Method)
        if !validMethods[method] </span><span class="cov0" title="0">{
                return fmt.Errorf("method must be either TOTP or HOTP")
        }</span>

        <span class="cov0" title="0">o.Method = method
        return nil</span>
}

// isValidBase32 checks if a string contains only valid base32 characters
func isValidBase32(s string) bool <span class="cov0" title="0">{
        // Base32 alphabet: A-Z (26 letters) + 2-7 (6 digits) = 32 characters
        base32Regex := regexp.MustCompile(`^[A-Z2-7]+$`)
        return base32Regex.MatchString(s)
}</span>

// SetDefaults sets default values for optional fields
func (o *OTP) SetDefaults() <span class="cov0" title="0">{
        if o.Algorithm == "" </span><span class="cov0" title="0">{
                o.Algorithm = "SHA1"
        }</span>
        <span class="cov0" title="0">if o.Digits == 0 </span><span class="cov0" title="0">{
                o.Digits = 6
        }</span>
        <span class="cov0" title="0">if o.Period == 0 &amp;&amp; o.Method == "TOTP" </span><span class="cov0" title="0">{
                o.Period = 30
        }</span>
        <span class="cov0" title="0">if o.Method == "" </span><span class="cov0" title="0">{
                o.Method = "TOTP"
        }</span>
        <span class="cov0" title="0">if o.Counter == 0 &amp;&amp; o.Method == "HOTP" </span><span class="cov0" title="0">{
                o.Counter = 0
        }</span>
}

// SetDefaultsForEdit sets default values for optional fields during edit
// Only sets defaults for fields that are zero/empty
func (o *OTP) SetDefaultsForEdit() <span class="cov0" title="0">{
        // Don't override existing values, only set if empty/zero
        if o.Algorithm == "" </span><span class="cov0" title="0">{
                o.Algorithm = "SHA1"
        }</span>
        <span class="cov0" title="0">if o.Digits == 0 </span><span class="cov0" title="0">{
                o.Digits = 6
        }</span>
        <span class="cov0" title="0">if o.Period == 0 &amp;&amp; (o.Method == "TOTP" || o.Method == "") </span><span class="cov0" title="0">{
                o.Period = 30
        }</span>
        <span class="cov0" title="0">if o.Method == "" </span><span class="cov0" title="0">{
                o.Method = "TOTP"
        }</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">package config

import (
        "fmt"
        "os"
        "strconv"
        "strings"
        "time"

        "github.com/joho/godotenv"
)

// Config holds all configuration for the application
type Config struct {
        Server   ServerConfig
        Database DatabaseConfig
        JWT      JWTConfig
        WebAuthn WebAuthnConfig
        OAuth    OAuthConfig
        Security SecurityConfig
}

// ServerConfig holds server-related configuration
type ServerConfig struct {
        Host            string
        Port            int
        Environment     string
        ShutdownTimeout time.Duration
        ReadTimeout     time.Duration
        WriteTimeout    time.Duration
        MaxHeaderBytes  int
}

// DatabaseConfig holds database-related configuration
type DatabaseConfig struct {
        Host            string
        Port            int
        Name            string
        User            string
        Password        string
        SSLMode         string
        MaxConnections  int
        MaxIdleConns    int
        ConnMaxLifetime time.Duration
        ConnMaxIdleTime time.Duration
}

// JWTConfig holds JWT-related configuration
type JWTConfig struct {
        SigningKey     string
        ExpirationTime time.Duration
        RefreshTime    time.Duration
        Issuer         string
        Audience       string
}

// WebAuthnConfig holds WebAuthn-related configuration
type WebAuthnConfig struct {
        RPDisplayName string
        RPID          string
        RPOrigins     []string
        Timeout       time.Duration
}

// OAuthConfig holds OAuth-related configuration
type OAuthConfig struct {
        Google        OAuthProviderConfig
        GitHub        OAuthProviderConfig
        Microsoft     OAuthProviderConfig
        SessionSecret string
        SessionMaxAge int
}

// OAuthProviderConfig holds configuration for a specific OAuth provider
type OAuthProviderConfig struct {
        ClientID     string
        ClientSecret string
        CallbackURL  string
        Scopes       []string
        Enabled      bool
}

// SecurityConfig holds security-related configuration
type SecurityConfig struct {
        RateLimitRPS   int
        RateLimitBurst int
        CORSOrigins    []string
        CSPPolicy      string
}

// Load loads configuration from environment variables
func Load() (*Config, error) <span class="cov0" title="0">{
        // Load .env file if it exists (for development)
        _ = godotenv.Load()

        config := &amp;Config{
                Server: ServerConfig{
                        Host:            getEnv("SERVER_HOST", "localhost"),
                        Port:            getEnvAsInt("SERVER_PORT", 8080),
                        Environment:     getEnv("ENVIRONMENT", "development"),
                        ShutdownTimeout: getEnvAsDuration("SERVER_SHUTDOWN_TIMEOUT", 30*time.Second),
                        ReadTimeout:     getEnvAsDuration("SERVER_READ_TIMEOUT", 15*time.Second),
                        WriteTimeout:    getEnvAsDuration("SERVER_WRITE_TIMEOUT", 15*time.Second),
                        MaxHeaderBytes:  getEnvAsInt("SERVER_MAX_HEADER_BYTES", 1&lt;&lt;20), // 1MB
                },
                Database: DatabaseConfig{
                        Host:            getEnv("DB_HOST", "localhost"),
                        Port:            getEnvAsInt("DB_PORT", 5432),
                        Name:            getEnv("DB_NAME", "2fair"),
                        User:            getEnv("DB_USER", "postgres"),
                        Password:        getEnv("DB_PASSWORD", ""),
                        SSLMode:         getEnv("DB_SSL_MODE", "disable"),
                        MaxConnections:  getEnvAsInt("DB_MAX_CONNECTIONS", 25),
                        MaxIdleConns:    getEnvAsInt("DB_MAX_IDLE_CONNS", 5),
                        ConnMaxLifetime: getEnvAsDuration("DB_CONN_MAX_LIFETIME", 5*time.Minute),
                        ConnMaxIdleTime: getEnvAsDuration("DB_CONN_MAX_IDLE_TIME", 1*time.Minute),
                },
                JWT: JWTConfig{
                        SigningKey:     getEnv("JWT_SIGNING_KEY", ""),
                        ExpirationTime: getEnvAsDuration("JWT_EXPIRATION_TIME", 1*time.Hour),
                        RefreshTime:    getEnvAsDuration("JWT_REFRESH_TIME", 24*time.Hour),
                        Issuer:         getEnv("JWT_ISSUER", "2fair.dev"),
                        Audience:       getEnv("JWT_AUDIENCE", "2fair.dev"),
                },
                WebAuthn: WebAuthnConfig{
                        RPDisplayName: getEnv("WEBAUTHN_RP_DISPLAY_NAME", "2FAir"),
                        RPID:          getEnv("WEBAUTHN_RP_ID", ""),
                        RPOrigins:     getEnvAsSlice("WEBAUTHN_RP_ORIGINS", []string{"http://localhost:3000", "http://localhost:8080"}),
                        Timeout:       getEnvAsDuration("WEBAUTHN_TIMEOUT", 60*time.Second),
                },
                OAuth: OAuthConfig{
                        Google: OAuthProviderConfig{
                                ClientID:     getEnv("OAUTH_GOOGLE_CLIENT_ID", ""),
                                ClientSecret: getEnv("OAUTH_GOOGLE_CLIENT_SECRET", ""),
                                CallbackURL:  getEnv("OAUTH_GOOGLE_CALLBACK_URL", "http://localhost:8080/auth/oauth/callback/google"),
                                Scopes:       getEnvAsSlice("OAUTH_GOOGLE_SCOPES", []string{"email", "profile"}),
                                Enabled:      getEnvAsBool("OAUTH_GOOGLE_ENABLED", false),
                        },
                        GitHub: OAuthProviderConfig{
                                ClientID:     getEnv("OAUTH_GITHUB_CLIENT_ID", ""),
                                ClientSecret: getEnv("OAUTH_GITHUB_CLIENT_SECRET", ""),
                                CallbackURL:  getEnv("OAUTH_GITHUB_CALLBACK_URL", "http://localhost:8080/auth/oauth/callback/github"),
                                Scopes:       getEnvAsSlice("OAUTH_GITHUB_SCOPES", []string{"user:email"}),
                                Enabled:      getEnvAsBool("OAUTH_GITHUB_ENABLED", false),
                        },
                        Microsoft: OAuthProviderConfig{
                                ClientID:     getEnv("OAUTH_MICROSOFT_CLIENT_ID", ""),
                                ClientSecret: getEnv("OAUTH_MICROSOFT_CLIENT_SECRET", ""),
                                CallbackURL:  getEnv("OAUTH_MICROSOFT_CALLBACK_URL", "http://localhost:8080/auth/oauth/callback/microsoft"),
                                Scopes:       getEnvAsSlice("OAUTH_MICROSOFT_SCOPES", []string{"https://graph.microsoft.com/User.Read"}),
                                Enabled:      getEnvAsBool("OAUTH_MICROSOFT_ENABLED", false),
                        },
                        SessionSecret: getEnv("OAUTH_SESSION_SECRET", ""),
                        SessionMaxAge: getEnvAsInt("OAUTH_SESSION_MAX_AGE", 86400), // 24 hours
                },
                Security: SecurityConfig{
                        RateLimitRPS:   getEnvAsInt("RATE_LIMIT_RPS", 100),
                        RateLimitBurst: getEnvAsInt("RATE_LIMIT_BURST", 200),
                        CORSOrigins:    getEnvAsSlice("CORS_ORIGINS", []string{"http://localhost:3000"}),
                        CSPPolicy:      getEnv("CSP_POLICY", "default-src 'self'; script-src 'self'; style-src 'self' 'unsafe-inline'"),
                },
        }

        // Validate required configuration
        if err := config.Validate(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid configuration: %w", err)
        }</span>

        <span class="cov0" title="0">return config, nil</span>
}

// Validate validates the configuration
func (c *Config) Validate() error <span class="cov0" title="0">{
        if c.JWT.SigningKey == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("JWT_SIGNING_KEY is required")
        }</span>

        <span class="cov0" title="0">if c.Database.Password == "" &amp;&amp; c.Server.Environment == "production" </span><span class="cov0" title="0">{
                return fmt.Errorf("DB_PASSWORD is required in production")
        }</span>

        <span class="cov0" title="0">if c.WebAuthn.RPID == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("WEBAUTHN_RP_ID is required")
        }</span>

        <span class="cov0" title="0">if len(c.WebAuthn.RPOrigins) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("WEBAUTHN_RP_ORIGINS is required")
        }</span>

        // Validate OAuth configuration
        <span class="cov0" title="0">if c.OAuth.SessionSecret == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("OAUTH_SESSION_SECRET is required")
        }</span>

        // Validate OAuth providers if enabled
        <span class="cov0" title="0">if c.OAuth.Google.Enabled &amp;&amp; (c.OAuth.Google.ClientID == "" || c.OAuth.Google.ClientSecret == "") </span><span class="cov0" title="0">{
                return fmt.Errorf("Google OAuth enabled but OAUTH_GOOGLE_CLIENT_ID or OAUTH_GOOGLE_CLIENT_SECRET is missing")
        }</span>

        <span class="cov0" title="0">if c.OAuth.GitHub.Enabled &amp;&amp; (c.OAuth.GitHub.ClientID == "" || c.OAuth.GitHub.ClientSecret == "") </span><span class="cov0" title="0">{
                return fmt.Errorf("GitHub OAuth enabled but OAUTH_GITHUB_CLIENT_ID or OAUTH_GITHUB_CLIENT_SECRET is missing")
        }</span>

        <span class="cov0" title="0">if c.OAuth.Microsoft.Enabled &amp;&amp; (c.OAuth.Microsoft.ClientID == "" || c.OAuth.Microsoft.ClientSecret == "") </span><span class="cov0" title="0">{
                return fmt.Errorf("Microsoft OAuth enabled but OAUTH_MICROSOFT_CLIENT_ID or OAUTH_MICROSOFT_CLIENT_SECRET is missing")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetDatabaseURL returns the PostgreSQL connection URL
func (c *Config) GetDatabaseURL() string <span class="cov0" title="0">{
        return fmt.Sprintf(
                "host=%s port=%d user=%s password=%s dbname=%s sslmode=%s",
                c.Database.Host,
                c.Database.Port,
                c.Database.User,
                c.Database.Password,
                c.Database.Name,
                c.Database.SSLMode,
        )
}</span>

// IsDevelopment returns true if the environment is development
func (c *Config) IsDevelopment() bool <span class="cov0" title="0">{
        return c.Server.Environment == "development"
}</span>

// IsProduction returns true if the environment is production
func (c *Config) IsProduction() bool <span class="cov0" title="0">{
        return c.Server.Environment == "production"
}</span>

// GetServerAddress returns the server address
func (c *Config) GetServerAddress() string <span class="cov0" title="0">{
        return fmt.Sprintf("%s:%d", c.Server.Host, c.Server.Port)
}</span>

// Helper functions for environment variable parsing

func getEnv(key, defaultValue string) string <span class="cov0" title="0">{
        if value := os.Getenv(key); value != "" </span><span class="cov0" title="0">{
                return value
        }</span>
        <span class="cov0" title="0">return defaultValue</span>
}

func getEnvAsInt(key string, defaultValue int) int <span class="cov0" title="0">{
        if value := os.Getenv(key); value != "" </span><span class="cov0" title="0">{
                if intValue, err := strconv.Atoi(value); err == nil </span><span class="cov0" title="0">{
                        return intValue
                }</span>
        }
        <span class="cov0" title="0">return defaultValue</span>
}

func getEnvAsDuration(key string, defaultValue time.Duration) time.Duration <span class="cov0" title="0">{
        if value := os.Getenv(key); value != "" </span><span class="cov0" title="0">{
                if duration, err := time.ParseDuration(value); err == nil </span><span class="cov0" title="0">{
                        return duration
                }</span>
        }
        <span class="cov0" title="0">return defaultValue</span>
}

func getEnvAsSlice(key string, defaultValue []string) []string <span class="cov0" title="0">{
        if value := os.Getenv(key); value != "" </span><span class="cov0" title="0">{
                // Split comma-separated values and trim spaces
                parts := []string{}
                for _, part := range strings.Split(value, ",") </span><span class="cov0" title="0">{
                        trimmed := strings.TrimSpace(part)
                        if trimmed != "" </span><span class="cov0" title="0">{
                                parts = append(parts, trimmed)
                        }</span>
                }
                <span class="cov0" title="0">if len(parts) &gt; 0 </span><span class="cov0" title="0">{
                        return parts
                }</span>
        }
        <span class="cov0" title="0">return defaultValue</span>
}

func getEnvAsBool(key string, defaultValue bool) bool <span class="cov0" title="0">{
        if value := os.Getenv(key); value != "" </span><span class="cov0" title="0">{
                if boolValue, err := strconv.ParseBool(value); err == nil </span><span class="cov0" title="0">{
                        return boolValue
                }</span>
        }
        <span class="cov0" title="0">return defaultValue</span>
}
</pre>
		
		<pre class="file" id="file37" style="display: none">package configs

import (
        "log"
        "os"
        "regexp"

        "github.com/joho/godotenv"
)

const projectDirName = "server"

func LoadEnv() <span class="cov0" title="0">{
        projectName := regexp.MustCompile(`^(.*` + projectDirName + `)`)
        currentWorkDirectory, _ := os.Getwd()
        rootPath := projectName.Find([]byte(currentWorkDirectory))

        err := godotenv.Load(string(rootPath) + `/.env`)

        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Could not load .env file: %v", err)
        }</span>
}

func GetEnv(key string) string <span class="cov0" title="0">{
        return os.Getenv(key)
}</span>
</pre>
		
		<pre class="file" id="file38" style="display: none">package database

import (
        "database/sql"
        "fmt"

        _ "github.com/lib/pq" // PostgreSQL driver for goose
        "github.com/pressly/goose/v3"

        "github.com/bug-breeder/2fair/server/internal/infrastructure/config"
)

// MigrationManager handles database migrations
type MigrationManager struct {
        db  *sql.DB
        cfg *config.Config
}

// NewMigrationManager creates a new migration manager
func NewMigrationManager(cfg *config.Config) (*MigrationManager, error) <span class="cov0" title="0">{
        // Create a standard sql.DB connection for goose
        db, err := sql.Open("postgres", cfg.GetDatabaseURL())
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to open database connection: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;MigrationManager{
                db:  db,
                cfg: cfg,
        }, nil</span>
}

// Close closes the migration manager database connection
func (m *MigrationManager) Close() error <span class="cov0" title="0">{
        return m.db.Close()
}</span>

// Up runs all pending migrations
func (m *MigrationManager) Up() error <span class="cov0" title="0">{
        goose.SetBaseFS(nil)

        if err := goose.SetDialect("postgres"); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to set dialect: %w", err)
        }</span>

        // Migration files are located in the migrations directory
        <span class="cov0" title="0">migrationDir := "internal/adapter/database/migrations"

        if err := goose.Up(m.db, migrationDir); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to run migrations: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Down rolls back migrations
func (m *MigrationManager) Down() error <span class="cov0" title="0">{
        goose.SetBaseFS(nil)

        if err := goose.SetDialect("postgres"); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to set dialect: %w", err)
        }</span>

        <span class="cov0" title="0">migrationDir := "internal/adapter/database/migrations"

        if err := goose.Down(m.db, migrationDir); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to rollback migration: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Status shows the migration status
func (m *MigrationManager) Status() error <span class="cov0" title="0">{
        goose.SetBaseFS(nil)

        if err := goose.SetDialect("postgres"); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to set dialect: %w", err)
        }</span>

        <span class="cov0" title="0">migrationDir := "internal/adapter/database/migrations"

        if err := goose.Status(m.db, migrationDir); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get migration status: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Version shows the current migration version
func (m *MigrationManager) Version() (int64, error) <span class="cov0" title="0">{
        goose.SetBaseFS(nil)

        if err := goose.SetDialect("postgres"); err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to set dialect: %w", err)
        }</span>

        <span class="cov0" title="0">version, err := goose.GetDBVersion(m.db)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to get database version: %w", err)
        }</span>

        <span class="cov0" title="0">return version, nil</span>
}

// Create creates a new migration file
func (m *MigrationManager) Create(name string) error <span class="cov0" title="0">{
        migrationDir := "internal/adapter/database/migrations"

        if err := goose.Create(m.db, migrationDir, name, "sql"); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create migration: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// RunMigrations is a convenience function to run migrations during application startup
func RunMigrations(cfg *config.Config) error <span class="cov0" title="0">{
        migrationManager, err := NewMigrationManager(cfg)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create migration manager: %w", err)
        }</span>
        <span class="cov0" title="0">defer migrationManager.Close()

        if err := migrationManager.Up(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to run migrations: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file39" style="display: none">package database

import (
        "context"
        "fmt"
        "time"

        "github.com/jackc/pgx/v5"
        "github.com/jackc/pgx/v5/pgxpool"

        "github.com/bug-breeder/2fair/server/internal/infrastructure/config"
)

// DB wraps the pgxpool.Pool with additional functionality
type DB struct {
        Pool *pgxpool.Pool
}

// NewDB creates a new database connection pool
func NewDB(cfg *config.Config) (*DB, error) <span class="cov0" title="0">{
        // Create connection config
        poolConfig, err := pgxpool.ParseConfig(cfg.GetDatabaseURL())
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse database URL: %w", err)
        }</span>

        // Configure connection pool
        <span class="cov0" title="0">poolConfig.MaxConns = int32(cfg.Database.MaxConnections)
        poolConfig.MaxConnIdleTime = cfg.Database.ConnMaxIdleTime
        poolConfig.MaxConnLifetime = cfg.Database.ConnMaxLifetime
        poolConfig.MinConns = int32(cfg.Database.MaxIdleConns)

        // Create connection pool
        pool, err := pgxpool.NewWithConfig(context.Background(), poolConfig)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create connection pool: %w", err)
        }</span>

        <span class="cov0" title="0">db := &amp;DB{
                Pool: pool,
        }

        // Test the connection
        if err := db.Ping(context.Background()); err != nil </span><span class="cov0" title="0">{
                pool.Close()
                return nil, fmt.Errorf("failed to ping database: %w", err)
        }</span>

        <span class="cov0" title="0">return db, nil</span>
}

// Ping tests the database connection
func (db *DB) Ping(ctx context.Context) error <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(ctx, 5*time.Second)
        defer cancel()

        return db.Pool.Ping(ctx)
}</span>

// Close closes the database connection pool
func (db *DB) Close() <span class="cov0" title="0">{
        db.Pool.Close()
}</span>

// Health returns database health information
func (db *DB) Health(ctx context.Context) (*HealthInfo, error) <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(ctx, 5*time.Second)
        defer cancel()

        stats := db.Pool.Stat()

        // Test connection
        if err := db.Pool.Ping(ctx); err != nil </span><span class="cov0" title="0">{
                return &amp;HealthInfo{
                        Status:  "unhealthy",
                        Message: fmt.Sprintf("failed to ping database: %v", err),
                }, err
        }</span>

        <span class="cov0" title="0">return &amp;HealthInfo{
                Status:               "healthy",
                Message:              "database connection is healthy",
                AcquiredConns:        int(stats.AcquiredConns()),
                IdleConns:            int(stats.IdleConns()),
                MaxConns:             int(stats.MaxConns()),
                TotalConns:           int(stats.TotalConns()),
                NewConnsCount:        stats.NewConnsCount(),
                AcquireCount:         stats.AcquireCount(),
                AcquireDuration:      stats.AcquireDuration(),
                EmptyAcquireCount:    stats.EmptyAcquireCount(),
                CanceledAcquireCount: stats.CanceledAcquireCount(),
        }, nil</span>
}

// HealthInfo contains database health information
type HealthInfo struct {
        Status               string        `json:"status"`
        Message              string        `json:"message"`
        AcquiredConns        int           `json:"acquired_conns"`
        IdleConns            int           `json:"idle_conns"`
        MaxConns             int           `json:"max_conns"`
        TotalConns           int           `json:"total_conns"`
        NewConnsCount        int64         `json:"new_conns_count"`
        AcquireCount         int64         `json:"acquire_count"`
        AcquireDuration      time.Duration `json:"acquire_duration"`
        EmptyAcquireCount    int64         `json:"empty_acquire_count"`
        CanceledAcquireCount int64         `json:"canceled_acquire_count"`
}

// WithTransaction executes a function within a database transaction
func (db *DB) WithTransaction(ctx context.Context, fn func(tx pgx.Tx) error) error <span class="cov0" title="0">{
        tx, err := db.Pool.Begin(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to begin transaction: %w", err)
        }</span>

        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if p := recover(); p != nil </span><span class="cov0" title="0">{
                        _ = tx.Rollback(ctx)
                        panic(p)</span>
                }
        }()

        <span class="cov0" title="0">if err := fn(tx); err != nil </span><span class="cov0" title="0">{
                if rbErr := tx.Rollback(ctx); rbErr != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("transaction failed: %v, rollback failed: %w", err, rbErr)
                }</span>
                <span class="cov0" title="0">return err</span>
        }

        <span class="cov0" title="0">if err := tx.Commit(ctx); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to commit transaction: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file40" style="display: none">package jwt

import (
        "errors"
        "time"

        "github.com/dgrijalva/jwt-go"
        "github.com/google/uuid"
)

var (
        ErrInvalidToken = errors.New("invalid token")
        ErrExpiredToken = errors.New("token has expired")
        ErrTokenClaims  = errors.New("invalid token claims")
)

// TokenClaims represents the JWT claims structure
type TokenClaims struct {
        UserID   uuid.UUID `json:"user_id"`
        Username string    `json:"username"`
        Email    string    `json:"email"`
        jwt.StandardClaims
}

// TokenService handles JWT token operations
type TokenService struct {
        signingKey        []byte
        issuer            string
        expiration        time.Duration
        refreshExpiration time.Duration
}

// NewTokenService creates a new TokenService instance
func NewTokenService(signingKey string, issuer string, expiration, refreshExpiration time.Duration) *TokenService <span class="cov0" title="0">{
        return &amp;TokenService{
                signingKey:        []byte(signingKey),
                issuer:            issuer,
                expiration:        expiration,
                refreshExpiration: refreshExpiration,
        }
}</span>

// GenerateToken creates a new access token for the user
func (ts *TokenService) GenerateToken(userID uuid.UUID, username, email string) (string, error) <span class="cov0" title="0">{
        now := time.Now()
        claims := &amp;TokenClaims{
                UserID:   userID,
                Username: username,
                Email:    email,
                StandardClaims: jwt.StandardClaims{
                        IssuedAt:  now.Unix(),
                        ExpiresAt: now.Add(ts.expiration).Unix(),
                        NotBefore: now.Unix(),
                        Issuer:    ts.issuer,
                        Subject:   userID.String(),
                },
        }

        token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
        return token.SignedString(ts.signingKey)
}</span>

// GenerateRefreshToken creates a new refresh token for the user
func (ts *TokenService) GenerateRefreshToken(userID uuid.UUID) (string, error) <span class="cov0" title="0">{
        now := time.Now()
        claims := &amp;jwt.StandardClaims{
                IssuedAt:  now.Unix(),
                ExpiresAt: now.Add(ts.refreshExpiration).Unix(),
                NotBefore: now.Unix(),
                Issuer:    ts.issuer,
                Subject:   userID.String(),
        }

        token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
        return token.SignedString(ts.signingKey)
}</span>

// ValidateToken validates and parses a JWT token
func (ts *TokenService) ValidateToken(tokenString string) (*TokenClaims, error) <span class="cov0" title="0">{
        token, err := jwt.ParseWithClaims(tokenString, &amp;TokenClaims{}, func(token *jwt.Token) (interface{}, error) </span><span class="cov0" title="0">{
                if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok </span><span class="cov0" title="0">{
                        return nil, ErrInvalidToken
                }</span>
                <span class="cov0" title="0">return ts.signingKey, nil</span>
        })

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                if ve, ok := err.(*jwt.ValidationError); ok </span><span class="cov0" title="0">{
                        if ve.Errors&amp;jwt.ValidationErrorExpired != 0 </span><span class="cov0" title="0">{
                                return nil, ErrExpiredToken
                        }</span>
                }
                <span class="cov0" title="0">return nil, ErrInvalidToken</span>
        }

        <span class="cov0" title="0">claims, ok := token.Claims.(*TokenClaims)
        if !ok || !token.Valid </span><span class="cov0" title="0">{
                return nil, ErrTokenClaims
        }</span>

        <span class="cov0" title="0">return claims, nil</span>
}

// ValidateRefreshToken validates a refresh token and returns the user ID
func (ts *TokenService) ValidateRefreshToken(tokenString string) (uuid.UUID, error) <span class="cov0" title="0">{
        token, err := jwt.ParseWithClaims(tokenString, &amp;jwt.StandardClaims{}, func(token *jwt.Token) (interface{}, error) </span><span class="cov0" title="0">{
                if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok </span><span class="cov0" title="0">{
                        return nil, ErrInvalidToken
                }</span>
                <span class="cov0" title="0">return ts.signingKey, nil</span>
        })

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                if ve, ok := err.(*jwt.ValidationError); ok </span><span class="cov0" title="0">{
                        if ve.Errors&amp;jwt.ValidationErrorExpired != 0 </span><span class="cov0" title="0">{
                                return uuid.Nil, ErrExpiredToken
                        }</span>
                }
                <span class="cov0" title="0">return uuid.Nil, ErrInvalidToken</span>
        }

        <span class="cov0" title="0">claims, ok := token.Claims.(*jwt.StandardClaims)
        if !ok || !token.Valid </span><span class="cov0" title="0">{
                return uuid.Nil, ErrTokenClaims
        }</span>

        <span class="cov0" title="0">userID, err := uuid.Parse(claims.Subject)
        if err != nil </span><span class="cov0" title="0">{
                return uuid.Nil, ErrTokenClaims
        }</span>

        <span class="cov0" title="0">return userID, nil</span>
}

// TokenPair represents an access and refresh token pair
type TokenPair struct {
        AccessToken  string    `json:"access_token"`
        RefreshToken string    `json:"refresh_token"`
        ExpiresAt    time.Time `json:"expires_at"`
        TokenType    string    `json:"token_type"`
}

// GenerateTokenPair creates both access and refresh tokens
func (ts *TokenService) GenerateTokenPair(userID uuid.UUID, username, email string) (*TokenPair, error) <span class="cov0" title="0">{
        accessToken, err := ts.GenerateToken(userID, username, email)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">refreshToken, err := ts.GenerateRefreshToken(userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;TokenPair{
                AccessToken:  accessToken,
                RefreshToken: refreshToken,
                ExpiresAt:    time.Now().Add(ts.expiration),
                TokenType:    "Bearer",
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file41" style="display: none">package oauth

import (
        "context"
        "errors"
        "fmt"
        "log/slog"
        "net/url"
        "time"

        "github.com/gorilla/sessions"
        "github.com/markbates/goth"
        "github.com/markbates/goth/gothic"
        "github.com/markbates/goth/providers/github"
        "github.com/markbates/goth/providers/google"

        "github.com/bug-breeder/2fair/server/internal/domain/entities"
        "github.com/bug-breeder/2fair/server/internal/domain/repositories"
)

var (
        ErrProviderNotSupported = errors.New("oauth provider not supported")
        ErrAuthenticationFailed = errors.New("oauth authentication failed")
        ErrUserInfoRetrieval    = errors.New("failed to retrieve user information")
)

// ProviderConfig represents OAuth provider configuration
type ProviderConfig struct {
        ClientID     string
        ClientSecret string
        CallbackURL  string
        Scopes       []string
}

// Config represents OAuth service configuration
type Config struct {
        Providers     map[string]ProviderConfig
        SessionSecret string
        SessionMaxAge int
}

// OAuthService handles OAuth authentication with multiple providers
type OAuthService struct {
        config   Config
        userRepo repositories.UserRepository
        logger   *slog.Logger
        store    sessions.Store
}

// NewOAuthService creates a new OAuth service
func NewOAuthService(config Config, userRepo repositories.UserRepository, logger *slog.Logger) *OAuthService <span class="cov0" title="0">{
        // Initialize session store
        store := sessions.NewCookieStore([]byte(config.SessionSecret))
        store.MaxAge(config.SessionMaxAge)
        store.Options.HttpOnly = true
        store.Options.Secure = true // Set to true in production with HTTPS
        store.Options.SameSite = 1  // Strict

        gothic.Store = store

        service := &amp;OAuthService{
                config:   config,
                userRepo: userRepo,
                logger:   logger,
                store:    store,
        }

        // Initialize providers
        service.initializeProviders()

        return service
}</span>

// initializeProviders sets up OAuth providers based on configuration
func (s *OAuthService) initializeProviders() <span class="cov0" title="0">{
        var providers []goth.Provider

        // Google OAuth
        if googleConfig, exists := s.config.Providers["google"]; exists </span><span class="cov0" title="0">{
                scopes := googleConfig.Scopes
                if len(scopes) == 0 </span><span class="cov0" title="0">{
                        scopes = []string{"email", "profile"}
                }</span>
                <span class="cov0" title="0">providers = append(providers, google.New(
                        googleConfig.ClientID,
                        googleConfig.ClientSecret,
                        googleConfig.CallbackURL,
                        scopes...,
                ))
                s.logger.Info("Google OAuth provider initialized")</span>
        }

        // Microsoft OAuth - temporarily disabled due to import issues
        // if microsoftConfig, exists := s.config.Providers["microsoft"]; exists {
        //         scopes := microsoftConfig.Scopes
        //         if len(scopes) == 0 {
        //                 scopes = []string{"https://graph.microsoft.com/User.Read"}
        //         }
        //         providers = append(providers, microsoft.New(
        //                 microsoftConfig.ClientID,
        //                 microsoftConfig.ClientSecret,
        //                 microsoftConfig.CallbackURL,
        //                 scopes...,
        //         ))
        //         s.logger.Info("Microsoft OAuth provider initialized")
        // }

        // GitHub OAuth
        <span class="cov0" title="0">if githubConfig, exists := s.config.Providers["github"]; exists </span><span class="cov0" title="0">{
                scopes := githubConfig.Scopes
                if len(scopes) == 0 </span><span class="cov0" title="0">{
                        scopes = []string{"user:email"}
                }</span>
                <span class="cov0" title="0">providers = append(providers, github.New(
                        githubConfig.ClientID,
                        githubConfig.ClientSecret,
                        githubConfig.CallbackURL,
                        scopes...,
                ))
                s.logger.Info("GitHub OAuth provider initialized")</span>
        }

        <span class="cov0" title="0">goth.UseProviders(providers...)
        s.logger.Info("OAuth providers initialized", "count", len(providers))</span>
}

// GetSupportedProviders returns a list of supported OAuth providers
func (s *OAuthService) GetSupportedProviders() []string <span class="cov0" title="0">{
        var providers []string
        for provider := range s.config.Providers </span><span class="cov0" title="0">{
                providers = append(providers, provider)
        }</span>
        <span class="cov0" title="0">return providers</span>
}

// GetAuthURL returns the OAuth authorization URL for the specified provider
func (s *OAuthService) GetAuthURL(provider, state string) (string, error) <span class="cov0" title="0">{
        if !s.isProviderSupported(provider) </span><span class="cov0" title="0">{
                return "", ErrProviderNotSupported
        }</span>

        // Get the provider
        <span class="cov0" title="0">gothProvider, err := goth.GetProvider(provider)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to get OAuth provider", "provider", provider, "error", err)
                return "", ErrProviderNotSupported
        }</span>

        // Begin auth process
        <span class="cov0" title="0">session, err := gothProvider.BeginAuth(state)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to begin OAuth", "provider", provider, "error", err)
                return "", ErrAuthenticationFailed
        }</span>

        <span class="cov0" title="0">authURL, err := session.GetAuthURL()
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to get auth URL", "provider", provider, "error", err)
                return "", ErrAuthenticationFailed
        }</span>

        <span class="cov0" title="0">s.logger.Info("Generated OAuth auth URL", "provider", provider)
        return authURL, nil</span>
}

// CompleteAuth completes the OAuth authentication flow
func (s *OAuthService) CompleteAuth(ctx context.Context, provider, code, state string) (*entities.User, error) <span class="cov0" title="0">{
        if !s.isProviderSupported(provider) </span><span class="cov0" title="0">{
                return nil, ErrProviderNotSupported
        }</span>

        // Get the provider
        <span class="cov0" title="0">gothProvider, err := goth.GetProvider(provider)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to get OAuth provider", "provider", provider, "error", err)
                return nil, ErrProviderNotSupported
        }</span>

        // Create session from state
        <span class="cov0" title="0">session, err := gothProvider.UnmarshalSession(state)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to unmarshal session", "provider", provider, "error", err)
                return nil, ErrAuthenticationFailed
        }</span>

        // Exchange authorization code for access token
        <span class="cov0" title="0">_, err = session.Authorize(gothProvider, url.Values{"code": {code}})
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to authorize", "provider", provider, "error", err)
                return nil, ErrAuthenticationFailed
        }</span>

        // Get user information
        <span class="cov0" title="0">gothUser, err := gothProvider.FetchUser(session)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to fetch user", "provider", provider, "error", err)
                return nil, ErrUserInfoRetrieval
        }</span>

        <span class="cov0" title="0">s.logger.Info("OAuth user fetched successfully",
                "provider", provider,
                "user_id", gothUser.UserID,
                "email", gothUser.Email)

        // Create or update user
        user, err := s.createOrUpdateUser(ctx, &amp;gothUser, provider)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to create/update user", "error", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">return user, nil</span>
}

// createOrUpdateUser creates a new user or updates existing user from OAuth data
func (s *OAuthService) createOrUpdateUser(ctx context.Context, gothUser *goth.User, provider string) (*entities.User, error) <span class="cov0" title="0">{
        // Try to find existing user by email
        existingUser, err := s.userRepo.GetByEmail(ctx, gothUser.Email)
        if err != nil &amp;&amp; !errors.Is(err, entities.ErrUserNotFound) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to check existing user: %w", err)
        }</span>

        <span class="cov0" title="0">if existingUser != nil </span><span class="cov0" title="0">{
                // Update existing user
                existingUser.DisplayName = gothUser.Name
                existingUser.UpdatedAt = time.Now()

                err = s.userRepo.Update(ctx, existingUser)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to update user: %w", err)
                }</span>

                <span class="cov0" title="0">s.logger.Info("Updated existing user", "user_id", existingUser.ID, "email", existingUser.Email)
                return existingUser, nil</span>
        }

        // Create new user
        <span class="cov0" title="0">username := s.generateUsername(gothUser.Email, gothUser.NickName)

        newUser := &amp;entities.User{
                Username:    username,
                Email:       gothUser.Email,
                DisplayName: gothUser.Name,
                CreatedAt:   time.Now(),
                UpdatedAt:   time.Now(),
        }

        err = s.userRepo.Create(ctx, newUser)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create user: %w", err)
        }</span>

        <span class="cov0" title="0">s.logger.Info("Created new user", "user_id", newUser.ID, "email", newUser.Email, "provider", provider)
        return newUser, nil</span>
}

// generateUsername generates a unique username from email or nickname
func (s *OAuthService) generateUsername(email, nickname string) string <span class="cov0" title="0">{
        if nickname != "" </span><span class="cov0" title="0">{
                return nickname
        }</span>

        // Extract username from email
        <span class="cov0" title="0">if email != "" </span><span class="cov0" title="0">{
                at := 0
                for i, c := range email </span><span class="cov0" title="0">{
                        if c == '@' </span><span class="cov0" title="0">{
                                at = i
                                break</span>
                        }
                }
                <span class="cov0" title="0">if at &gt; 0 </span><span class="cov0" title="0">{
                        return email[:at]
                }</span>
        }

        // Fallback to random username
        <span class="cov0" title="0">return "user_" + time.Now().Format("20060102150405")</span>
}

// isProviderSupported checks if the provider is supported
func (s *OAuthService) isProviderSupported(provider string) bool <span class="cov0" title="0">{
        _, exists := s.config.Providers[provider]
        return exists
}</span>

// GetUserProfile retrieves user profile information from OAuth provider
func (s *OAuthService) GetUserProfile(ctx context.Context, provider, accessToken string) (*goth.User, error) <span class="cov0" title="0">{
        if !s.isProviderSupported(provider) </span><span class="cov0" title="0">{
                return nil, ErrProviderNotSupported
        }</span>

        // This function needs to be implemented properly with the correct session handling
        // For now, returning an error to indicate it's not implemented
        <span class="cov0" title="0">return nil, errors.New("not implemented")</span>
}
</pre>
		
		<pre class="file" id="file42" style="display: none">package services

import (
        "context"
        "fmt"
        "time"

        "github.com/bug-breeder/2fair/server/internal/domain/entities"
        "github.com/bug-breeder/2fair/server/internal/domain/repositories"
        "github.com/bug-breeder/2fair/server/internal/domain/services"
        "github.com/golang-jwt/jwt/v5"
        "github.com/google/uuid"
        "github.com/markbates/goth"
        "github.com/markbates/goth/providers/github"
        "github.com/markbates/goth/providers/google"
)

type authService struct {
        userRepo  repositories.UserRepository
        jwtSecret []byte
        jwtExpiry time.Duration
        serverURL string
}

// NewAuthService creates a new authentication service
func NewAuthService(
        userRepo repositories.UserRepository,
        jwtSecret string,
        jwtExpiry time.Duration,
        serverURL string,
        googleClientID string,
        googleClientSecret string,
        githubClientID string,
        githubClientSecret string,
) services.AuthService <span class="cov8" title="1">{
        // Configure OAuth providers
        goth.UseProviders(
                google.New(
                        googleClientID,
                        googleClientSecret,
                        fmt.Sprintf("%s/auth/google/callback", serverURL),
                ),
                github.New(
                        githubClientID,
                        githubClientSecret,
                        fmt.Sprintf("%s/auth/github/callback", serverURL),
                ),
        )

        return &amp;authService{
                userRepo:  userRepo,
                jwtSecret: []byte(jwtSecret),
                jwtExpiry: jwtExpiry,
                serverURL: serverURL,
        }
}</span>

// GetOAuthAuthURL generates OAuth authorization URL
func (a *authService) GetOAuthAuthURL(provider string, state string) (string, error) <span class="cov0" title="0">{
        // Validate provider
        switch provider </span>{
        case "google", "github":<span class="cov0" title="0"></span>
                // Provider is valid
        default:<span class="cov0" title="0">
                return "", fmt.Errorf("unsupported OAuth provider: %s", provider)</span>
        }

        // Create authentication URL
        <span class="cov0" title="0">authURL := fmt.Sprintf("%s/auth/%s?state=%s", a.serverURL, provider, state)
        return authURL, nil</span>
}

// HandleOAuthCallback processes OAuth callback
func (a *authService) HandleOAuthCallback(provider string, code string, state string) (*services.OAuthProvider, error) <span class="cov0" title="0">{
        // This would typically be handled by the Gin handler using gothic.CompleteUserAuth
        // For now, return a placeholder implementation
        return nil, fmt.Errorf("handleOAuthCallback should be implemented in the HTTP handler")
}</span>

// RegisterOrLoginUser registers or logs in a user from OAuth data
func (a *authService) RegisterOrLoginUser(ctx context.Context, oauthData *services.OAuthProvider) (*entities.User, error) <span class="cov8" title="1">{
        // Try to find existing user by email
        existingUser, err := a.userRepo.GetByEmail(ctx, oauthData.Email)
        if err != nil &amp;&amp; err != entities.ErrUserNotFound </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to check existing user: %w", err)
        }</span>

        <span class="cov8" title="1">if existingUser != nil </span><span class="cov8" title="1">{
                // Update last login using the entity method
                existingUser.UpdateLastLogin()

                if err := a.userRepo.Update(ctx, existingUser); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to update user login time: %w", err)
                }</span>

                <span class="cov8" title="1">return existingUser, nil</span>
        }

        // Create new user
        <span class="cov8" title="1">now := time.Now()
        user := &amp;entities.User{
                ID:          uuid.New(),
                Username:    oauthData.Username,
                Email:       oauthData.Email,
                DisplayName: oauthData.DisplayName,
                IsActive:    true,
                CreatedAt:   now,
                UpdatedAt:   now,
                LastLoginAt: &amp;now,
        }

        // Validate user data
        if err := user.Validate(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid user data: %w", err)
        }</span>

        // Create user
        <span class="cov8" title="1">if err := a.userRepo.Create(ctx, user); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create user: %w", err)
        }</span>

        <span class="cov8" title="1">return user, nil</span>
}

// GenerateJWT creates a JWT token for the user
func (a *authService) GenerateJWT(user *entities.User) (string, error) <span class="cov8" title="1">{
        now := time.Now()
        expiresAt := now.Add(a.jwtExpiry)

        claims := &amp;services.JWTClaims{
                UserID:    user.ID.String(),
                Username:  user.Username,
                Email:     user.Email,
                IssuedAt:  now,
                ExpiresAt: expiresAt,
        }

        token := jwt.NewWithClaims(jwt.SigningMethodHS256, jwt.MapClaims{
                "user_id":  claims.UserID,
                "username": claims.Username,
                "email":    claims.Email,
                "iat":      claims.IssuedAt.Unix(),
                "exp":      claims.ExpiresAt.Unix(),
        })

        tokenString, err := token.SignedString(a.jwtSecret)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to sign JWT token: %w", err)
        }</span>

        <span class="cov8" title="1">return tokenString, nil</span>
}

// ValidateJWT validates and parses a JWT token
func (a *authService) ValidateJWT(tokenString string) (*services.JWTClaims, error) <span class="cov8" title="1">{
        token, err := jwt.Parse(tokenString, func(token *jwt.Token) (interface{}, error) </span><span class="cov8" title="1">{
                if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"])
                }</span>
                <span class="cov8" title="1">return a.jwtSecret, nil</span>
        })

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to parse JWT token: %w", err)
        }</span>

        <span class="cov8" title="1">if !token.Valid </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid JWT token")
        }</span>

        <span class="cov8" title="1">claims, ok := token.Claims.(jwt.MapClaims)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid JWT claims format")
        }</span>

        // Extract claims
        <span class="cov8" title="1">userID, ok := claims["user_id"].(string)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid user_id in JWT claims")
        }</span>

        <span class="cov8" title="1">username, ok := claims["username"].(string)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid username in JWT claims")
        }</span>

        <span class="cov8" title="1">email, ok := claims["email"].(string)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid email in JWT claims")
        }</span>

        <span class="cov8" title="1">iat, ok := claims["iat"].(float64)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid iat in JWT claims")
        }</span>

        <span class="cov8" title="1">exp, ok := claims["exp"].(float64)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid exp in JWT claims")
        }</span>

        <span class="cov8" title="1">return &amp;services.JWTClaims{
                UserID:    userID,
                Username:  username,
                Email:     email,
                IssuedAt:  time.Unix(int64(iat), 0),
                ExpiresAt: time.Unix(int64(exp), 0),
        }, nil</span>
}

// RefreshJWT refreshes a JWT token
func (a *authService) RefreshJWT(tokenString string) (string, error) <span class="cov8" title="1">{
        claims, err := a.ValidateJWT(tokenString)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to validate existing token: %w", err)
        }</span>

        // Check if token is expired
        <span class="cov8" title="1">if time.Now().After(claims.ExpiresAt) </span><span class="cov0" title="0">{
                return "", fmt.Errorf("token is expired")
        }</span>

        // Generate new token with same claims but updated timestamps
        <span class="cov8" title="1">now := time.Now()
        expiresAt := now.Add(a.jwtExpiry)

        newClaims := &amp;services.JWTClaims{
                UserID:    claims.UserID,
                Username:  claims.Username,
                Email:     claims.Email,
                IssuedAt:  now,
                ExpiresAt: expiresAt,
        }

        token := jwt.NewWithClaims(jwt.SigningMethodHS256, jwt.MapClaims{
                "user_id":  newClaims.UserID,
                "username": newClaims.Username,
                "email":    newClaims.Email,
                "iat":      newClaims.IssuedAt.Unix(),
                "exp":      newClaims.ExpiresAt.Unix(),
        })

        newTokenString, err := token.SignedString(a.jwtSecret)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to sign new JWT token: %w", err)
        }</span>

        <span class="cov8" title="1">return newTokenString, nil</span>
}
</pre>
		
		<pre class="file" id="file43" style="display: none">package services

import (
        "context"
        "fmt"
        "net/http"
        "time"

        "github.com/bug-breeder/2fair/server/internal/domain/entities"
        "github.com/bug-breeder/2fair/server/internal/domain/repositories"
        "github.com/bug-breeder/2fair/server/internal/domain/services"
        "github.com/go-webauthn/webauthn/protocol"
        "github.com/go-webauthn/webauthn/webauthn"
        "github.com/google/uuid"
)

type webAuthnService struct {
        webAuthn *webauthn.WebAuthn
        credRepo repositories.WebAuthnCredentialRepository
        userRepo repositories.UserRepository
}

// NewWebAuthnService creates a new WebAuthn service
func NewWebAuthnService(
        rpID string,
        rpName string,
        rpOrigins []string,
        credRepo repositories.WebAuthnCredentialRepository,
        userRepo repositories.UserRepository,
) (services.WebAuthnService, error) <span class="cov8" title="1">{
        // Validate required parameters
        if rpID == "" </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("RPID is required")
        }</span>
        <span class="cov8" title="1">if rpName == "" </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("RP display name is required")
        }</span>
        <span class="cov8" title="1">if len(rpOrigins) == 0 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("at least one RP origin is required")
        }</span>

        <span class="cov8" title="1">config := &amp;webauthn.Config{
                RPDisplayName: rpName,
                RPID:          rpID,
                RPOrigins:     rpOrigins,
                Debug:         false,
        }

        webAuthn, err := webauthn.New(config)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create WebAuthn instance: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;webAuthnService{
                webAuthn: webAuthn,
                credRepo: credRepo,
                userRepo: userRepo,
        }, nil</span>
}

// webAuthnUser implements webauthn.User interface
type webAuthnUser struct {
        user        *entities.User
        credentials []*entities.WebAuthnCredential
}

func (u *webAuthnUser) WebAuthnID() []byte <span class="cov0" title="0">{
        return []byte(u.user.ID.String())
}</span>

func (u *webAuthnUser) WebAuthnName() string <span class="cov0" title="0">{
        return u.user.Email
}</span>

func (u *webAuthnUser) WebAuthnDisplayName() string <span class="cov0" title="0">{
        return u.user.DisplayName
}</span>

func (u *webAuthnUser) WebAuthnCredentials() []webauthn.Credential <span class="cov0" title="0">{
        credentials := make([]webauthn.Credential, len(u.credentials))
        for i, cred := range u.credentials </span><span class="cov0" title="0">{
                // Convert transport strings to AuthenticatorTransport
                transports := make([]protocol.AuthenticatorTransport, len(cred.Transport))
                for j, t := range cred.Transport </span><span class="cov0" title="0">{
                        transports[j] = protocol.AuthenticatorTransport(t)
                }</span>

                // Convert AAGUID from *uuid.UUID to []byte
                <span class="cov0" title="0">var aaguid []byte
                if cred.AAGUID != nil </span><span class="cov0" title="0">{
                        aaguidBytes, _ := cred.AAGUID.MarshalBinary()
                        aaguid = aaguidBytes
                }</span>

                <span class="cov0" title="0">credentials[i] = webauthn.Credential{
                        ID:              cred.CredentialID,
                        PublicKey:       cred.PublicKey,
                        AttestationType: "none", // Default attestation type
                        Transport:       transports,
                        Flags: webauthn.CredentialFlags{
                                UserPresent:    true, // Default to true
                                UserVerified:   true, // Default to true
                                BackupEligible: cred.BackupEligible,
                                BackupState:    cred.BackupState,
                        },
                        Authenticator: webauthn.Authenticator{
                                AAGUID:    aaguid,
                                SignCount: uint32(cred.SignCount),
                        },
                }</span>
        }
        <span class="cov0" title="0">return credentials</span>
}

func (u *webAuthnUser) WebAuthnIcon() string <span class="cov0" title="0">{
        return ""
}</span>

// BeginRegistration starts WebAuthn credential registration
func (w *webAuthnService) BeginRegistration(ctx context.Context, user *entities.User, authenticatorSelection *protocol.AuthenticatorSelection) (*services.WebAuthnCredentialCreation, error) <span class="cov0" title="0">{
        // Get existing credentials for the user
        existingCreds, err := w.credRepo.GetByUserID(ctx, user.ID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get existing credentials: %w", err)
        }</span>

        <span class="cov0" title="0">webAuthnUser := &amp;webAuthnUser{
                user:        user,
                credentials: existingCreds,
        }

        // Create registration options
        registerOptions := func(credCreationOpts *protocol.PublicKeyCredentialCreationOptions) </span><span class="cov0" title="0">{
                if authenticatorSelection != nil </span><span class="cov0" title="0">{
                        credCreationOpts.AuthenticatorSelection = *authenticatorSelection
                }</span>

                // Enable PRF extension for key derivation
                <span class="cov0" title="0">credCreationOpts.Extensions = protocol.AuthenticationExtensions{
                        "prf": map[string]interface{}{},
                }</span>
        }

        <span class="cov0" title="0">credentialCreation, sessionData, err := w.webAuthn.BeginRegistration(webAuthnUser, registerOptions)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to begin registration: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;services.WebAuthnCredentialCreation{
                PublicKeyCredentialCreationOptions: credentialCreation,
                SessionData:                        sessionData,
        }, nil</span>
}

// FinishRegistration completes WebAuthn credential registration
func (w *webAuthnService) FinishRegistration(ctx context.Context, user *entities.User, sessionData *webauthn.SessionData, request *http.Request) (*entities.WebAuthnCredential, error) <span class="cov0" title="0">{
        // Get existing credentials for the user
        existingCreds, err := w.credRepo.GetByUserID(ctx, user.ID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get existing credentials: %w", err)
        }</span>

        <span class="cov0" title="0">webAuthnUser := &amp;webAuthnUser{
                user:        user,
                credentials: existingCreds,
        }

        credential, err := w.webAuthn.FinishRegistration(webAuthnUser, *sessionData, request)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to finish registration: %w", err)
        }</span>

        // Convert AAGUID from []byte to *uuid.UUID
        <span class="cov0" title="0">var aaguid *uuid.UUID
        if len(credential.Authenticator.AAGUID) &gt; 0 </span><span class="cov0" title="0">{
                if parsed, err := uuid.FromBytes(credential.Authenticator.AAGUID); err == nil </span><span class="cov0" title="0">{
                        aaguid = &amp;parsed
                }</span>
        }

        // Convert transport types
        <span class="cov0" title="0">var transports []string
        for _, transport := range credential.Transport </span><span class="cov0" title="0">{
                transports = append(transports, string(transport))
        }</span>

        // Create credential entity with correct field mapping
        <span class="cov0" title="0">credEntity := &amp;entities.WebAuthnCredential{
                ID:             uuid.New(),
                UserID:         user.ID,
                CredentialID:   credential.ID,
                PublicKey:      credential.PublicKey,
                AAGUID:         aaguid,
                CloneWarning:   false,
                Attachment:     "", // Will be set via SetAttachment if needed
                Transport:      transports,
                BackupEligible: credential.Flags.BackupEligible,
                BackupState:    credential.Flags.BackupState,
                SignCount:      uint64(credential.Authenticator.SignCount),
                CreatedAt:      time.Now(),
                LastUsedAt:     nil, // Will be set on first use
        }

        // Validate and create credential
        if err := credEntity.Validate(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid credential: %w", err)
        }</span>

        <span class="cov0" title="0">if err := w.credRepo.Create(ctx, credEntity); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to store credential: %w", err)
        }</span>

        <span class="cov0" title="0">return credEntity, nil</span>
}

// BeginAssertion starts WebAuthn credential assertion
func (w *webAuthnService) BeginAssertion(ctx context.Context, user *entities.User, allowedCredentials []protocol.CredentialDescriptor) (*services.WebAuthnCredentialAssertion, error) <span class="cov0" title="0">{
        // Get existing credentials for the user
        existingCreds, err := w.credRepo.GetByUserID(ctx, user.ID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get existing credentials: %w", err)
        }</span>

        <span class="cov0" title="0">if len(existingCreds) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no credentials found for user")
        }</span>

        <span class="cov0" title="0">webAuthnUser := &amp;webAuthnUser{
                user:        user,
                credentials: existingCreds,
        }

        // Create assertion options with PRF extension
        assertionOptions := func(credAssertionOpts *protocol.PublicKeyCredentialRequestOptions) </span><span class="cov0" title="0">{
                if len(allowedCredentials) &gt; 0 </span><span class="cov0" title="0">{
                        credAssertionOpts.AllowedCredentials = allowedCredentials
                }</span>

                // Enable PRF extension for key derivation
                <span class="cov0" title="0">credAssertionOpts.Extensions = protocol.AuthenticationExtensions{
                        "prf": map[string]interface{}{
                                "eval": map[string]interface{}{
                                        "first": "dGVzdC1wcmYtaW5wdXQ=", // Base64 encoded PRF input
                                },
                        },
                }</span>
        }

        <span class="cov0" title="0">credentialAssertion, sessionData, err := w.webAuthn.BeginLogin(webAuthnUser, assertionOptions)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to begin assertion: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;services.WebAuthnCredentialAssertion{
                PublicKeyCredentialRequestOptions: credentialAssertion,
                SessionData:                       sessionData,
        }, nil</span>
}

// FinishAssertion completes WebAuthn credential assertion
func (w *webAuthnService) FinishAssertion(ctx context.Context, user *entities.User, sessionData *webauthn.SessionData, request *http.Request) (*entities.WebAuthnCredential, []byte, error) <span class="cov0" title="0">{
        // Get existing credentials for the user
        existingCreds, err := w.credRepo.GetByUserID(ctx, user.ID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("failed to get existing credentials: %w", err)
        }</span>

        <span class="cov0" title="0">webAuthnUser := &amp;webAuthnUser{
                user:        user,
                credentials: existingCreds,
        }

        credential, err := w.webAuthn.FinishLogin(webAuthnUser, *sessionData, request)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("failed to finish assertion: %w", err)
        }</span>

        // Find the credential entity
        <span class="cov0" title="0">var credEntity *entities.WebAuthnCredential
        for _, cred := range existingCreds </span><span class="cov0" title="0">{
                if string(cred.CredentialID) == string(credential.ID) </span><span class="cov0" title="0">{
                        credEntity = cred
                        break</span>
                }
        }

        <span class="cov0" title="0">if credEntity == nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("credential not found")
        }</span>

        // Update sign count using entity method
        <span class="cov0" title="0">credEntity.UpdateSignCount(uint64(credential.Authenticator.SignCount))

        if err := w.credRepo.Update(ctx, credEntity); err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("failed to update credential: %w", err)
        }</span>

        // For PRF extension support, the output would be available in the credential response
        // This is a simplified implementation - actual PRF output extraction would require
        // parsing the credential response for PRF extension data
        <span class="cov0" title="0">var prfOutput []byte
        // TODO: Extract PRF output from credential response when PRF extension is used

        return credEntity, prfOutput, nil</span>
}

// DeriveVaultKey derives a vault encryption key using PRF
func (w *webAuthnService) DeriveVaultKey(ctx context.Context, user *entities.User, credentialID []byte, prfInput []byte) ([]byte, error) <span class="cov8" title="1">{
        // This is a simplified implementation
        // In practice, you would trigger a WebAuthn assertion with PRF extension
        // and return the derived key from the authenticator
        return nil, fmt.Errorf("DeriveVaultKey should be called through the assertion flow")
}</span>

// GetUserCredentials retrieves all WebAuthn credentials for a user
func (w *webAuthnService) GetUserCredentials(ctx context.Context, userID string) ([]*entities.WebAuthnCredential, error) <span class="cov8" title="1">{
        // Convert string userID to UUID
        userUUID, err := uuid.Parse(userID)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("invalid user ID format: %w", err)
        }</span>

        <span class="cov8" title="1">credentials, err := w.credRepo.GetByUserID(ctx, userUUID)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to get WebAuthn credentials: %w", err)
        }</span>

        <span class="cov8" title="1">return credentials, nil</span>
}

// DeleteCredential deletes a WebAuthn credential
func (w *webAuthnService) DeleteCredential(ctx context.Context, userID string, credentialID []byte) error <span class="cov8" title="1">{
        // Convert string userID to UUID
        userUUID, err := uuid.Parse(userID)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid user ID format: %w", err)
        }</span>

        <span class="cov8" title="1">if err := w.credRepo.Delete(ctx, credentialID, userUUID); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to delete WebAuthn credential: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file44" style="display: none">package test

import (
        "context"
        "database/sql"
        "fmt"
        "log"
        "os"
        "testing"
        "time"

        "github.com/ory/dockertest/v3"
        "github.com/ory/dockertest/v3/docker"
        "github.com/stretchr/testify/suite"

        "github.com/bug-breeder/2fair/server/internal/domain/entities"
        "github.com/bug-breeder/2fair/server/internal/infrastructure/config"
        "github.com/bug-breeder/2fair/server/internal/infrastructure/database"
)

// IntegrationTestSuite provides a base for integration tests
type IntegrationTestSuite struct {
        suite.Suite
        DB       *database.DB
        Config   *config.Config
        pool     *dockertest.Pool
        resource *dockertest.Resource
}

// SetupSuite runs before all tests in the suite
func (suite *IntegrationTestSuite) SetupSuite() <span class="cov0" title="0">{
        // Skip integration tests if running unit tests only
        if testing.Short() </span><span class="cov0" title="0">{
                suite.T().Skip("Skipping integration tests in short mode")
        }</span>

        // Setup Docker test environment
        <span class="cov0" title="0">pool, err := dockertest.NewPool("")
        if err != nil </span><span class="cov0" title="0">{
                suite.T().Fatalf("Could not connect to Docker: %s", err)
        }</span>
        <span class="cov0" title="0">suite.pool = pool

        // Pull PostgreSQL image and run container
        resource, err := pool.RunWithOptions(&amp;dockertest.RunOptions{
                Repository: "postgres",
                Tag:        "15-alpine",
                Env: []string{
                        "POSTGRES_PASSWORD=testpassword",
                        "POSTGRES_USER=testuser",
                        "POSTGRES_DB=testdb",
                        "listen_addresses = '*'",
                },
        }, func(config *docker.HostConfig) </span><span class="cov0" title="0">{
                config.AutoRemove = true
                config.RestartPolicy = docker.RestartPolicy{Name: "no"}
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                suite.T().Fatalf("Could not start PostgreSQL container: %s", err)
        }</span>
        <span class="cov0" title="0">suite.resource = resource

        // Set expiration for container cleanup
        if err := resource.Expire(120); err != nil </span><span class="cov0" title="0">{
                suite.T().Fatalf("Could not set container expiration: %s", err)
        }</span>

        // Setup test configuration
        <span class="cov0" title="0">suite.setupTestConfig()

        // Wait for database to be ready
        pool.MaxWait = 120 * time.Second
        if err := pool.Retry(func() error </span><span class="cov0" title="0">{
                db, err := sql.Open("postgres", suite.Config.GetDatabaseURL())
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">defer db.Close()
                return db.Ping()</span>
        }); err != nil <span class="cov0" title="0">{
                suite.T().Fatalf("Could not connect to PostgreSQL container: %s", err)
        }</span>

        // Initialize database connection
        <span class="cov0" title="0">suite.DB, err = database.NewDB(suite.Config)
        if err != nil </span><span class="cov0" title="0">{
                suite.T().Fatalf("Could not initialize database: %s", err)
        }</span>

        // Run migrations
        <span class="cov0" title="0">if err := database.RunMigrations(suite.Config); err != nil </span><span class="cov0" title="0">{
                suite.T().Fatalf("Could not run migrations: %s", err)
        }</span>

        <span class="cov0" title="0">suite.T().Log("Integration test suite setup complete")</span>
}

// TearDownSuite runs after all tests in the suite
func (suite *IntegrationTestSuite) TearDownSuite() <span class="cov0" title="0">{
        if suite.DB != nil </span><span class="cov0" title="0">{
                suite.DB.Close()
        }</span>

        <span class="cov0" title="0">if suite.pool != nil &amp;&amp; suite.resource != nil </span><span class="cov0" title="0">{
                if err := suite.pool.Purge(suite.resource); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Could not purge PostgreSQL container: %s", err)
                }</span>
        }

        <span class="cov0" title="0">suite.T().Log("Integration test suite teardown complete")</span>
}

// SetupTest runs before each test
func (suite *IntegrationTestSuite) SetupTest() <span class="cov0" title="0">{
        // Clean up database for each test
        suite.cleanupDatabase()
}</span>

// TearDownTest runs after each test
func (suite *IntegrationTestSuite) TearDownTest() {<span class="cov0" title="0">
        // Additional cleanup if needed
}</span>

// setupTestConfig creates a test configuration
func (suite *IntegrationTestSuite) setupTestConfig() <span class="cov0" title="0">{
        // Set test environment variables
        os.Setenv("DB_HOST", "localhost")
        os.Setenv("DB_PORT", suite.resource.GetPort("5432/tcp"))
        os.Setenv("DB_USER", "testuser")
        os.Setenv("DB_PASSWORD", "testpassword")
        os.Setenv("DB_NAME", "testdb")
        os.Setenv("DB_SSL_MODE", "disable")
        os.Setenv("JWT_SIGNING_KEY", "test-jwt-key-for-integration-tests")
        os.Setenv("OAUTH_SESSION_SECRET", "test-oauth-session-secret")
        os.Setenv("WEBAUTHN_RP_ID", "localhost")
        os.Setenv("WEBAUTHN_RP_DISPLAY_NAME", "2FAir Test")
        os.Setenv("WEBAUTHN_RP_ORIGINS", "http://localhost:3000")
        os.Setenv("ENVIRONMENT", "test")

        // Load configuration
        cfg, err := config.Load()
        if err != nil </span><span class="cov0" title="0">{
                suite.T().Fatalf("Could not load test configuration: %s", err)
        }</span>
        <span class="cov0" title="0">suite.Config = cfg</span>
}

// cleanupDatabase truncates all tables for clean test state
func (suite *IntegrationTestSuite) cleanupDatabase() <span class="cov0" title="0">{
        ctx := context.Background()

        // Get all table names
        rows, err := suite.DB.Pool.Query(ctx, `
                SELECT tablename FROM pg_tables 
                WHERE schemaname = 'public' 
                AND tablename != 'goose_db_version'
        `)
        if err != nil </span><span class="cov0" title="0">{
                suite.T().Fatalf("Could not get table names: %s", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var tables []string
        for rows.Next() </span><span class="cov0" title="0">{
                var tableName string
                if err := rows.Scan(&amp;tableName); err != nil </span><span class="cov0" title="0">{
                        suite.T().Fatalf("Could not scan table name: %s", err)
                }</span>
                <span class="cov0" title="0">tables = append(tables, tableName)</span>
        }

        // Truncate all tables
        <span class="cov0" title="0">for _, table := range tables </span><span class="cov0" title="0">{
                _, err := suite.DB.Pool.Exec(ctx, fmt.Sprintf("TRUNCATE TABLE %s CASCADE", table))
                if err != nil </span><span class="cov0" title="0">{
                        suite.T().Fatalf("Could not truncate table %s: %s", table, err)
                }</span>
        }
}

// CreateTestUser creates a test user for integration tests
func (suite *IntegrationTestSuite) CreateTestUser(username, email, displayName string) *entities.User <span class="cov0" title="0">{
        user := entities.NewUser(username, email, displayName)

        // In a real integration test, you would use the repository to create the user
        // For now, we just return the entity
        return user
}</span>

// AssertDatabaseConnection verifies the database connection is working
func (suite *IntegrationTestSuite) AssertDatabaseConnection() <span class="cov0" title="0">{
        ctx := context.Background()

        // Test basic query
        var result int
        err := suite.DB.Pool.QueryRow(ctx, "SELECT 1").Scan(&amp;result)
        suite.Require().NoError(err)
        suite.Assert().Equal(1, result)
}</span>

// GetTestConfig returns a configuration suitable for testing
func GetTestConfig() *config.Config <span class="cov0" title="0">{
        // Set test environment variables
        os.Setenv("JWT_SIGNING_KEY", "test-jwt-key")
        os.Setenv("OAUTH_SESSION_SECRET", "test-oauth-session-secret")
        os.Setenv("WEBAUTHN_RP_ID", "localhost")
        os.Setenv("WEBAUTHN_RP_DISPLAY_NAME", "2FAir Test")
        os.Setenv("WEBAUTHN_RP_ORIGINS", "http://localhost:3000")
        os.Setenv("ENVIRONMENT", "test")
        os.Setenv("DB_HOST", "localhost")
        os.Setenv("DB_PORT", "5432")
        os.Setenv("DB_USER", "testuser")
        os.Setenv("DB_PASSWORD", "testpassword")
        os.Setenv("DB_NAME", "testdb")
        os.Setenv("DB_SSL_MODE", "disable")

        cfg, err := config.Load()
        if err != nil </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("Could not load test configuration: %s", err))</span>
        }
        <span class="cov0" title="0">return cfg</span>
}
</pre>
		
		<pre class="file" id="file45" style="display: none">package auth

import (
        "context"
        "crypto/rand"
        "encoding/base64"
        "errors"
        "fmt"
        "log/slog"

        "github.com/google/uuid"

        "github.com/bug-breeder/2fair/server/internal/domain/entities"
        "github.com/bug-breeder/2fair/server/internal/domain/repositories"
        "github.com/bug-breeder/2fair/server/internal/infrastructure/jwt"
        "github.com/bug-breeder/2fair/server/internal/infrastructure/oauth"
)

var (
        ErrInvalidCredentials = errors.New("invalid credentials")
        ErrUserNotFound       = errors.New("user not found")
        ErrInvalidToken       = errors.New("invalid token")
        ErrTokenExpired       = errors.New("token expired")
)

// AuthService handles authentication operations
type AuthService struct {
        userRepo     repositories.UserRepository
        tokenService *jwt.TokenService
        oauthService *oauth.OAuthService
        logger       *slog.Logger
}

// NewAuthService creates a new authentication service
func NewAuthService(
        userRepo repositories.UserRepository,
        tokenService *jwt.TokenService,
        oauthService *oauth.OAuthService,
        logger *slog.Logger,
) *AuthService <span class="cov0" title="0">{
        return &amp;AuthService{
                userRepo:     userRepo,
                tokenService: tokenService,
                oauthService: oauthService,
                logger:       logger,
        }
}</span>

// AuthResult represents the result of an authentication operation
type AuthResult struct {
        User         *entities.User `json:"user"`
        AccessToken  string         `json:"access_token"`
        RefreshToken string         `json:"refresh_token"`
        ExpiresAt    int64          `json:"expires_at"`
        TokenType    string         `json:"token_type"`
}

// OAuthAuthRequest represents an OAuth authentication request
type OAuthAuthRequest struct {
        Provider string `json:"provider" validate:"required"`
        Code     string `json:"code" validate:"required"`
        State    string `json:"state" validate:"required"`
}

// RefreshTokenRequest represents a token refresh request
type RefreshTokenRequest struct {
        RefreshToken string `json:"refresh_token" validate:"required"`
}

// AuthenticateWithOAuth handles OAuth authentication flow
func (s *AuthService) AuthenticateWithOAuth(ctx context.Context, req *OAuthAuthRequest) (*AuthResult, error) <span class="cov0" title="0">{
        s.logger.Info("Starting OAuth authentication", "provider", req.Provider)

        // Complete OAuth authentication
        user, err := s.oauthService.CompleteAuth(ctx, req.Provider, req.Code, req.State)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("OAuth authentication failed", "provider", req.Provider, "error", err)
                return nil, fmt.Errorf("oauth authentication failed: %w", err)
        }</span>

        // Generate JWT tokens
        <span class="cov0" title="0">tokenPair, err := s.tokenService.GenerateTokenPair(user.ID, user.Username, user.Email)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to generate tokens", "user_id", user.ID, "error", err)
                return nil, fmt.Errorf("failed to generate tokens: %w", err)
        }</span>

        // Update last login time
        <span class="cov0" title="0">user.LastLoginAt = &amp;tokenPair.ExpiresAt
        err = s.userRepo.Update(ctx, user)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Warn("Failed to update last login time", "user_id", user.ID, "error", err)
                // Don't fail authentication if we can't update last login
        }</span>

        <span class="cov0" title="0">s.logger.Info("OAuth authentication successful", "user_id", user.ID, "provider", req.Provider)

        return &amp;AuthResult{
                User:         user,
                AccessToken:  tokenPair.AccessToken,
                RefreshToken: tokenPair.RefreshToken,
                ExpiresAt:    tokenPair.ExpiresAt.Unix(),
                TokenType:    tokenPair.TokenType,
        }, nil</span>
}

// GetOAuthAuthURL generates OAuth authorization URL
func (s *AuthService) GetOAuthAuthURL(provider string) (string, error) <span class="cov0" title="0">{
        s.logger.Info("Generating OAuth auth URL", "provider", provider)

        // Generate secure state parameter
        state, err := s.generateSecureState()
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to generate state", "error", err)
                return "", fmt.Errorf("failed to generate state: %w", err)
        }</span>

        <span class="cov0" title="0">authURL, err := s.oauthService.GetAuthURL(provider, state)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to get OAuth auth URL", "provider", provider, "error", err)
                return "", fmt.Errorf("failed to get auth URL: %w", err)
        }</span>

        <span class="cov0" title="0">s.logger.Info("Generated OAuth auth URL", "provider", provider)
        return authURL, nil</span>
}

// RefreshAccessToken refreshes an access token using a refresh token
func (s *AuthService) RefreshAccessToken(ctx context.Context, req *RefreshTokenRequest) (*AuthResult, error) <span class="cov0" title="0">{
        s.logger.Info("Refreshing access token")

        // Validate refresh token
        userID, err := s.tokenService.ValidateRefreshToken(req.RefreshToken)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Invalid refresh token", "error", err)
                if errors.Is(err, jwt.ErrExpiredToken) </span><span class="cov0" title="0">{
                        return nil, ErrTokenExpired
                }</span>
                <span class="cov0" title="0">return nil, ErrInvalidToken</span>
        }

        // Get user from database
        <span class="cov0" title="0">user, err := s.userRepo.GetByID(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("User not found for refresh token", "user_id", userID, "error", err)
                return nil, ErrUserNotFound
        }</span>

        // Generate new token pair
        <span class="cov0" title="0">tokenPair, err := s.tokenService.GenerateTokenPair(user.ID, user.Username, user.Email)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to generate new tokens", "user_id", user.ID, "error", err)
                return nil, fmt.Errorf("failed to generate tokens: %w", err)
        }</span>

        <span class="cov0" title="0">s.logger.Info("Access token refreshed successfully", "user_id", user.ID)

        return &amp;AuthResult{
                User:         user,
                AccessToken:  tokenPair.AccessToken,
                RefreshToken: tokenPair.RefreshToken,
                ExpiresAt:    tokenPair.ExpiresAt.Unix(),
                TokenType:    tokenPair.TokenType,
        }, nil</span>
}

// ValidateAccessToken validates an access token and returns user information
func (s *AuthService) ValidateAccessToken(tokenString string) (*entities.User, error) <span class="cov0" title="0">{
        // Validate JWT token
        claims, err := s.tokenService.ValidateToken(tokenString)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Debug("Invalid access token", "error", err)
                if errors.Is(err, jwt.ErrExpiredToken) </span><span class="cov0" title="0">{
                        return nil, ErrTokenExpired
                }</span>
                <span class="cov0" title="0">return nil, ErrInvalidToken</span>
        }

        // Return user information from claims
        <span class="cov0" title="0">user := &amp;entities.User{
                ID:       claims.UserID,
                Username: claims.Username,
                Email:    claims.Email,
        }

        return user, nil</span>
}

// GetUserByID retrieves a user by ID
func (s *AuthService) GetUserByID(ctx context.Context, userID uuid.UUID) (*entities.User, error) <span class="cov0" title="0">{
        user, err := s.userRepo.GetByID(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, entities.ErrUserNotFound) </span><span class="cov0" title="0">{
                        return nil, ErrUserNotFound
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get user: %w", err)</span>
        }
        <span class="cov0" title="0">return user, nil</span>
}

// GetSupportedOAuthProviders returns list of supported OAuth providers
func (s *AuthService) GetSupportedOAuthProviders() []string <span class="cov0" title="0">{
        return s.oauthService.GetSupportedProviders()
}</span>

// Logout handles user logout (primarily for cleanup/auditing)
func (s *AuthService) Logout(ctx context.Context, userID uuid.UUID) error <span class="cov0" title="0">{
        s.logger.Info("User logout", "user_id", userID)

        // In a JWT-based system, logout is typically handled client-side
        // by removing the token. However, we can log this for auditing purposes.

        // TODO: In the future, we might want to implement token blacklisting
        // or store active tokens in Redis for proper logout handling

        return nil
}</span>

// generateSecureState generates a cryptographically secure state parameter for OAuth
func (s *AuthService) generateSecureState() (string, error) <span class="cov0" title="0">{
        bytes := make([]byte, 32)
        _, err := rand.Read(bytes)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return base64.URLEncoding.EncodeToString(bytes), nil</span>
}

// UserInfo represents user information response
type UserInfo struct {
        ID          uuid.UUID `json:"id"`
        Username    string    `json:"username"`
        Email       string    `json:"email"`
        DisplayName string    `json:"display_name"`
        CreatedAt   int64     `json:"created_at"`
        UpdatedAt   int64     `json:"updated_at"`
}

// GetUserInfo returns user information for authenticated user
func (s *AuthService) GetUserInfo(ctx context.Context, userID uuid.UUID) (*UserInfo, error) <span class="cov0" title="0">{
        user, err := s.userRepo.GetByID(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, entities.ErrUserNotFound) </span><span class="cov0" title="0">{
                        return nil, ErrUserNotFound
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get user: %w", err)</span>
        }

        <span class="cov0" title="0">return &amp;UserInfo{
                ID:          user.ID,
                Username:    user.Username,
                Email:       user.Email,
                DisplayName: user.DisplayName,
                CreatedAt:   user.CreatedAt.Unix(),
                UpdatedAt:   user.UpdatedAt.Unix(),
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file46" style="display: none">package usecase

import (
        "context"
        "log"
        "strconv"
        "strings"
        "time"

        "github.com/bug-breeder/2fair/server/internal/adapter/repository"
        "github.com/bug-breeder/2fair/server/internal/domain/models"
        "github.com/bug-breeder/2fair/server/internal/utils"
)

type AuthUseCase struct {
        userRepo       repository.UserRepository
        loginEventRepo repository.LoginEventRepository
}

func NewAuthUseCase(userRepo repository.UserRepository, loginEventRepo repository.LoginEventRepository) *AuthUseCase <span class="cov0" title="0">{
        return &amp;AuthUseCase{
                userRepo:       userRepo,
                loginEventRepo: loginEventRepo,
        }
}</span>

func (uc *AuthUseCase) CompleteUserAuth(ctx context.Context, user *models.User, ipAddress, userAgent string) (string, string, error) <span class="cov0" title="0">{
        existingUser, err := uc.userRepo.FindByEmail(ctx, user.Email)
        if err != nil </span><span class="cov0" title="0">{
                // Check if it's a "not found" error, which is expected for new users
                if !strings.Contains(err.Error(), "user not found") </span><span class="cov0" title="0">{
                        log.Printf("Failed to check existing user: %v", err)
                        return "", "", err
                }</span>
                // User not found is expected for new users, set existingUser to nil
                <span class="cov0" title="0">existingUser = nil</span>
        }

        <span class="cov0" title="0">var (
                accessToken, refreshToken string
                userID                    int
        )

        if existingUser == nil </span><span class="cov0" title="0">{
                // No existing user found, create a new one
                userID, err = uc.userRepo.CreateUser(ctx, user)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Failed to create new user: %v", err)
                        return "", "", err
                }</span>
        } else<span class="cov0" title="0"> {
                // Existing user found, return the user info without updating
                userID = existingUser.ID
        }</span>

        // Log the login event
        <span class="cov0" title="0">loginEvent := models.LoginEvent{
                UserID:    userID,
                Timestamp: time.Now(),
                IPAddress: ipAddress,
                UserAgent: userAgent,
        }

        sessionID, err := uc.loginEventRepo.AddLoginEvent(ctx, &amp;loginEvent)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to log login event: %v", err)
                return "", "", err
        }</span>

        // Convert IDs to strings for token generation
        <span class="cov0" title="0">userIDStr := strconv.Itoa(userID)
        sessionIDStr := strconv.Itoa(sessionID)

        accessToken, err = utils.GenerateAccessToken(userIDStr)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to generate access token: %v", err)
                return "", "", err
        }</span>

        <span class="cov0" title="0">refreshToken, err = utils.GenerateRefreshToken(userIDStr, sessionIDStr)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to generate refresh token: %v", err)
                return "", "", err
        }</span>

        <span class="cov0" title="0">return accessToken, refreshToken, nil</span>
}

func (uc *AuthUseCase) GetCurrentUser(ctx context.Context, userID string) (*models.User, error) <span class="cov0" title="0">{
        userIDInt, err := strconv.Atoi(userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">user, err := uc.userRepo.FindByID(ctx, userIDInt)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return user, nil</span>
}

func (uc *AuthUseCase) ValidateToken(token string) (*models.Claims, error) <span class="cov0" title="0">{
        return utils.ValidateToken(token)
}</span>

func (uc *AuthUseCase) RefreshTokens(ctx context.Context, claims *models.Claims) (string, error) <span class="cov0" title="0">{
        userID := claims.UserID
        sessionID := claims.SessionID

        // Convert string IDs to integers
        userIDInt, err := strconv.Atoi(userID)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">sessionIDInt, err := strconv.Atoi(sessionID)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Validate sessionID
        <span class="cov0" title="0">_, err = uc.loginEventRepo.GetLoginEventByID(ctx, userIDInt, sessionIDInt)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">accessToken, err := utils.GenerateAccessToken(userID)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">return accessToken, nil</span>
}

func (uc *AuthUseCase) Logout(ctx context.Context, claims *models.Claims) error <span class="cov0" title="0">{
        userID := claims.UserID
        sessionID := claims.SessionID

        // Convert string IDs to integers
        userIDInt, err := strconv.Atoi(userID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">sessionIDInt, err := strconv.Atoi(sessionID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = uc.loginEventRepo.RemoveLoginEvent(ctx, userIDInt, sessionIDInt)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (uc *AuthUseCase) GetLoginHistory(ctx context.Context, userID string) ([]models.LoginEvent, error) <span class="cov0" title="0">{
        userIDInt, err := strconv.Atoi(userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Fetch login events from the dedicated repository
        <span class="cov0" title="0">loginEvents, err := uc.loginEventRepo.ListLoginEvents(ctx, userIDInt, 100) // Limiting to last 100 login events
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return loginEvents, nil</span>
}
</pre>
		
		<pre class="file" id="file47" style="display: none">package usecase

import (
        "context"
        "fmt"
        "log/slog"
        "strconv"
        "time"

        "github.com/bug-breeder/2fair/server/internal/adapter/repository"
        "github.com/bug-breeder/2fair/server/internal/domain/dto"
        "github.com/bug-breeder/2fair/server/internal/domain/models"
        "github.com/pquerna/otp/totp"
)

type OTPUseCase struct {
        otpRepo repository.OTPRepository
        logger  *slog.Logger
}

func NewOTPUseCase(otpRepo repository.OTPRepository) *OTPUseCase <span class="cov0" title="0">{
        return &amp;OTPUseCase{
                otpRepo: otpRepo,
                logger:  slog.Default().With("component", "OTPUseCase"),
        }
}</span>

func (uc *OTPUseCase) AddOTP(ctx context.Context, userID string, otp *models.OTP) error <span class="cov0" title="0">{
        uc.logger.Info("AddOTP use case called",
                "userID", userID,
                "issuer", otp.Issuer,
                "label", otp.Label)

        userIDInt, err := strconv.Atoi(userID)
        if err != nil </span><span class="cov0" title="0">{
                uc.logger.Error("Failed to convert userID to int",
                        "userID", userID,
                        "error", err)
                return err
        }</span>

        // Set defaults before validation
        <span class="cov0" title="0">otp.SetDefaults()

        // Validate and normalize OTP parameters
        if err := otp.ValidateAndNormalize(); err != nil </span><span class="cov0" title="0">{
                uc.logger.Warn("OTP validation failed",
                        "userID", userIDInt,
                        "issuer", otp.Issuer,
                        "error", err)
                return fmt.Errorf("validation failed: %w", err)
        }</span>

        <span class="cov0" title="0">uc.logger.Info("OTP validation successful",
                "userID", userIDInt,
                "issuer", otp.Issuer,
                "normalizedSecret", otp.Secret[:8]+"...")

        // The ID, CreatedAt and Active fields will be assigned by the database
        // In SQL we don't need to pre-assign ID as it's auto-incremented
        err = uc.otpRepo.AddOTP(ctx, userIDInt, otp)
        if err != nil </span><span class="cov0" title="0">{
                uc.logger.Error("Failed to add OTP",
                        "userID", userIDInt,
                        "issuer", otp.Issuer,
                        "error", err)
                return err
        }</span>

        <span class="cov0" title="0">uc.logger.Info("OTP added successfully",
                "userID", userIDInt,
                "issuer", otp.Issuer,
                "label", otp.Label)
        return nil</span>
}

func (uc *OTPUseCase) InactivateOTP(ctx context.Context, userID, otpID string) error <span class="cov0" title="0">{
        userIDInt, err := strconv.Atoi(userID)
        if err != nil </span><span class="cov0" title="0">{
                uc.logger.Error("Failed to convert userID to int",
                        "userID", userID,
                        "error", err)
                return err
        }</span>

        <span class="cov0" title="0">otpIDInt, err := strconv.Atoi(otpID)
        if err != nil </span><span class="cov0" title="0">{
                uc.logger.Error("Failed to convert otpID to int",
                        "otpID", otpID,
                        "error", err)
                return err
        }</span>

        <span class="cov0" title="0">err = uc.otpRepo.InactivateOTP(ctx, userIDInt, otpIDInt)
        if err != nil </span><span class="cov0" title="0">{
                uc.logger.Error("Failed to inactivate OTP",
                        "userID", userIDInt,
                        "otpID", otpIDInt,
                        "error", err)
                return err
        }</span>

        <span class="cov0" title="0">uc.logger.Info("OTP inactivated successfully",
                "userID", userIDInt,
                "otpID", otpIDInt)
        return nil</span>
}

func (uc *OTPUseCase) EditOTP(ctx context.Context, userID, otpID string, otp *models.OTP) error <span class="cov0" title="0">{
        uc.logger.Info("EditOTP use case called",
                "userID", userID,
                "otpID", otpID,
                "otp.Issuer", otp.Issuer,
                "otp.Label", otp.Label,
                "otp.Secret", otp.Secret,
                "otp.Algorithm", otp.Algorithm,
                "otp.Digits", otp.Digits,
                "otp.Period", otp.Period)

        userIDInt, err := strconv.Atoi(userID)
        if err != nil </span><span class="cov0" title="0">{
                uc.logger.Error("Failed to convert userID to int",
                        "userID", userID,
                        "error", err)
                return err
        }</span>

        <span class="cov0" title="0">otpIDInt, err := strconv.Atoi(otpID)
        if err != nil </span><span class="cov0" title="0">{
                uc.logger.Error("Failed to convert otpID to int",
                        "otpID", otpID,
                        "error", err)
                return err
        }</span>

        // Set defaults for edit (only for empty/zero fields)
        <span class="cov0" title="0">otp.SetDefaultsForEdit()

        // Validate only the fields being updated
        if err := otp.ValidateForEdit(); err != nil </span><span class="cov0" title="0">{
                uc.logger.Warn("OTP validation failed during edit",
                        "userID", userIDInt,
                        "otpID", otpIDInt,
                        "issuer", otp.Issuer,
                        "error", err)
                return fmt.Errorf("validation failed: %w", err)
        }</span>

        <span class="cov0" title="0">uc.logger.Info("EditOTP calling repository",
                "userIDInt", userIDInt,
                "otpIDInt", otpIDInt,
                "otp.Issuer", otp.Issuer,
                "otp.Label", otp.Label,
                "secretProvided", otp.Secret != "")

        err = uc.otpRepo.EditOTP(ctx, userIDInt, otpIDInt, otp)
        if err != nil </span><span class="cov0" title="0">{
                uc.logger.Error("Failed to edit OTP",
                        "userID", userIDInt,
                        "otpID", otpIDInt,
                        "error", err)
                return err
        }</span>

        <span class="cov0" title="0">uc.logger.Info("OTP edited successfully",
                "userID", userIDInt,
                "otpID", otpIDInt,
                "issuer", otp.Issuer)
        return nil</span>
}

func (uc *OTPUseCase) ListOTPs(ctx context.Context, userID string) ([]models.OTP, error) <span class="cov0" title="0">{
        userIDInt, err := strconv.Atoi(userID)
        if err != nil </span><span class="cov0" title="0">{
                uc.logger.Error("Failed to convert userID to int",
                        "userID", userID,
                        "error", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">otps, err := uc.otpRepo.ListOTPs(ctx, userIDInt)
        if err != nil </span><span class="cov0" title="0">{
                uc.logger.Error("Failed to list OTPs",
                        "userID", userIDInt,
                        "error", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">uc.logger.Debug("Listed OTPs successfully",
                "userID", userIDInt,
                "count", len(otps))
        return otps, nil</span>
}

func (uc *OTPUseCase) GenerateOTPCodes(ctx context.Context, userID string) ([]dto.GenerateOTPCodesResponse, error) <span class="cov0" title="0">{
        uc.logger.Debug("Starting OTP code generation", "userID", userID)

        userIDInt, err := strconv.Atoi(userID)
        if err != nil </span><span class="cov0" title="0">{
                uc.logger.Error("Failed to convert userID to int",
                        "userID", userID,
                        "error", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">uc.logger.Debug("Converted userID to int",
                "userID", userID,
                "userIDInt", userIDInt)

        otps, err := uc.otpRepo.ListOTPs(ctx, userIDInt)
        if err != nil </span><span class="cov0" title="0">{
                uc.logger.Error("Failed to list OTPs for code generation",
                        "userID", userIDInt,
                        "error", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">uc.logger.Debug("Found OTPs for code generation",
                "userID", userIDInt,
                "otpCount", len(otps))

        codes := make([]dto.GenerateOTPCodesResponse, len(otps))

        for i, otp := range otps </span><span class="cov0" title="0">{
                uc.logger.Debug("Processing OTP for code generation",
                        "index", i,
                        "otpID", otp.ID,
                        "issuer", otp.Issuer,
                        "period", otp.Period)

                now := time.Now()
                periodDuration := time.Duration(otp.Period) * time.Second

                currentExpireAt := now.Truncate(periodDuration).Add(periodDuration)

                currentCode, err := totp.GenerateCode(otp.Secret, now)
                if err != nil </span><span class="cov0" title="0">{
                        uc.logger.Error("Failed to generate current TOTP code",
                                "otpID", otp.ID,
                                "issuer", otp.Issuer,
                                "error", err)
                        return nil, err
                }</span>

                <span class="cov0" title="0">nextExpireAt := currentExpireAt.Add(periodDuration)
                nextTime := now.Add(periodDuration)
                nextCode, err := totp.GenerateCode(otp.Secret, nextTime)
                if err != nil </span><span class="cov0" title="0">{
                        uc.logger.Error("Failed to generate next TOTP code",
                                "otpID", otp.ID,
                                "issuer", otp.Issuer,
                                "error", err)
                        return nil, err
                }</span>

                <span class="cov0" title="0">codes[i] = dto.GenerateOTPCodesResponse{
                        ID:              otp.ID,
                        CurrentCode:     currentCode,
                        NextCode:        nextCode,
                        CurrentExpireAt: currentExpireAt,
                        NextExpireAt:    nextExpireAt,
                }

                uc.logger.Debug("Generated TOTP codes successfully",
                        "otpID", otp.ID,
                        "issuer", otp.Issuer,
                        "currentCode", currentCode,
                        "nextCode", nextCode)</span>
        }

        <span class="cov0" title="0">uc.logger.Info("Generated OTP codes successfully",
                "userID", userIDInt,
                "codeCount", len(codes))
        return codes, nil</span>
}
</pre>
		
		<pre class="file" id="file48" style="display: none">package utils

import (
        "time"

        "github.com/bug-breeder/2fair/server/internal/domain/models"
        "github.com/bug-breeder/2fair/server/internal/infrastructure/configs"
        "github.com/dgrijalva/jwt-go"
)

var jwtSecret = []byte(configs.GetEnv("AUTH_ACCESS_TOKEN_SECRET"))

// GenerateAccessToken generates a JWT access token
func GenerateAccessToken(userID string) (string, error) <span class="cov0" title="0">{
        expirationTime := time.Now().Add(15 * time.Minute) // 15 minutes
        claims := &amp;models.Claims{
                UserID:    userID,
                SessionID: "",
                StandardClaims: jwt.StandardClaims{
                        ExpiresAt: expirationTime.Unix(),
                },
        }
        token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
        return token.SignedString(jwtSecret)
}</span>

// GenerateRefreshToken generates a JWT refresh token
func GenerateRefreshToken(userID, sessionID string) (string, error) <span class="cov0" title="0">{
        expirationTime := time.Now().Add(180 * 24 * time.Hour) // 180 days
        claims := &amp;models.Claims{
                UserID:    userID,
                SessionID: sessionID,
                StandardClaims: jwt.StandardClaims{
                        ExpiresAt: expirationTime.Unix(),
                },
        }
        token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
        return token.SignedString(jwtSecret)
}</span>

// ValidateToken validates a JWT token and returns the claims
func ValidateToken(tokenStr string) (*models.Claims, error) <span class="cov0" title="0">{
        claims := &amp;models.Claims{}
        token, err := jwt.ParseWithClaims(tokenStr, claims, func(token *jwt.Token) (interface{}, error) </span><span class="cov0" title="0">{
                return jwtSecret, nil
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if !token.Valid </span><span class="cov0" title="0">{
                return nil, jwt.ErrSignatureInvalid
        }</span>
        <span class="cov0" title="0">return claims, nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
