// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: device_sessions.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createDeviceSession = `-- name: CreateDeviceSession :one
INSERT INTO device_sessions (
    user_id, device_fingerprint, device_name
)
VALUES ($1, $2, $3)
ON CONFLICT (user_id, device_fingerprint)
DO UPDATE SET
    device_name = EXCLUDED.device_name,
    last_sync_at = NOW()
RETURNING id, user_id, device_fingerprint, device_name, last_sync_at, created_at
`

type CreateDeviceSessionParams struct {
	UserID            pgtype.UUID `json:"user_id"`
	DeviceFingerprint string      `json:"device_fingerprint"`
	DeviceName        pgtype.Text `json:"device_name"`
}

func (q *Queries) CreateDeviceSession(ctx context.Context, arg CreateDeviceSessionParams) (DeviceSession, error) {
	row := q.db.QueryRow(ctx, createDeviceSession, arg.UserID, arg.DeviceFingerprint, arg.DeviceName)
	var i DeviceSession
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.DeviceFingerprint,
		&i.DeviceName,
		&i.LastSyncAt,
		&i.CreatedAt,
	)
	return i, err
}

const createSyncOperation = `-- name: CreateSyncOperation :one
INSERT INTO sync_operations (
    user_id, operation_type, entity_type, entity_id,
    operation_data, device_fingerprint
)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, user_id, operation_type, entity_type, entity_id, operation_data, device_fingerprint, timestamp
`

type CreateSyncOperationParams struct {
	UserID            pgtype.UUID `json:"user_id"`
	OperationType     string      `json:"operation_type"`
	EntityType        string      `json:"entity_type"`
	EntityID          pgtype.UUID `json:"entity_id"`
	OperationData     []byte      `json:"operation_data"`
	DeviceFingerprint string      `json:"device_fingerprint"`
}

func (q *Queries) CreateSyncOperation(ctx context.Context, arg CreateSyncOperationParams) (SyncOperation, error) {
	row := q.db.QueryRow(ctx, createSyncOperation,
		arg.UserID,
		arg.OperationType,
		arg.EntityType,
		arg.EntityID,
		arg.OperationData,
		arg.DeviceFingerprint,
	)
	var i SyncOperation
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.OperationType,
		&i.EntityType,
		&i.EntityID,
		&i.OperationData,
		&i.DeviceFingerprint,
		&i.Timestamp,
	)
	return i, err
}

const getActiveDeviceSessionsByUserID = `-- name: GetActiveDeviceSessionsByUserID :many
SELECT id, user_id, device_fingerprint, device_name, last_sync_at, created_at FROM device_sessions
WHERE user_id = $1
ORDER BY last_sync_at DESC
`

func (q *Queries) GetActiveDeviceSessionsByUserID(ctx context.Context, userID pgtype.UUID) ([]DeviceSession, error) {
	rows, err := q.db.Query(ctx, getActiveDeviceSessionsByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []DeviceSession{}
	for rows.Next() {
		var i DeviceSession
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.DeviceFingerprint,
			&i.DeviceName,
			&i.LastSyncAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDeviceSession = `-- name: GetDeviceSession :one
SELECT id, user_id, device_fingerprint, device_name, last_sync_at, created_at FROM device_sessions
WHERE user_id = $1 AND device_fingerprint = $2
`

type GetDeviceSessionParams struct {
	UserID            pgtype.UUID `json:"user_id"`
	DeviceFingerprint string      `json:"device_fingerprint"`
}

func (q *Queries) GetDeviceSession(ctx context.Context, arg GetDeviceSessionParams) (DeviceSession, error) {
	row := q.db.QueryRow(ctx, getDeviceSession, arg.UserID, arg.DeviceFingerprint)
	var i DeviceSession
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.DeviceFingerprint,
		&i.DeviceName,
		&i.LastSyncAt,
		&i.CreatedAt,
	)
	return i, err
}

const getLatestSyncTimestamp = `-- name: GetLatestSyncTimestamp :one
SELECT COALESCE(MAX(timestamp), NOW()) as latest_timestamp
FROM sync_operations
WHERE user_id = $1
`

func (q *Queries) GetLatestSyncTimestamp(ctx context.Context, userID pgtype.UUID) (interface{}, error) {
	row := q.db.QueryRow(ctx, getLatestSyncTimestamp, userID)
	var latest_timestamp interface{}
	err := row.Scan(&latest_timestamp)
	return latest_timestamp, err
}

const getSyncOperationsSince = `-- name: GetSyncOperationsSince :many
SELECT so.id, so.user_id, so.operation_type, so.entity_type, so.entity_id, so.operation_data, so.device_fingerprint, so.timestamp, ds.device_name
FROM sync_operations so
LEFT JOIN device_sessions ds ON so.device_fingerprint = ds.device_fingerprint AND so.user_id = ds.user_id
WHERE so.user_id = $1 AND so.timestamp > $2
ORDER BY so.timestamp ASC
`

type GetSyncOperationsSinceParams struct {
	UserID    pgtype.UUID        `json:"user_id"`
	Timestamp pgtype.Timestamptz `json:"timestamp"`
}

type GetSyncOperationsSinceRow struct {
	ID                pgtype.UUID        `json:"id"`
	UserID            pgtype.UUID        `json:"user_id"`
	OperationType     string             `json:"operation_type"`
	EntityType        string             `json:"entity_type"`
	EntityID          pgtype.UUID        `json:"entity_id"`
	OperationData     []byte             `json:"operation_data"`
	DeviceFingerprint string             `json:"device_fingerprint"`
	Timestamp         pgtype.Timestamptz `json:"timestamp"`
	DeviceName        pgtype.Text        `json:"device_name"`
}

func (q *Queries) GetSyncOperationsSince(ctx context.Context, arg GetSyncOperationsSinceParams) ([]GetSyncOperationsSinceRow, error) {
	rows, err := q.db.Query(ctx, getSyncOperationsSince, arg.UserID, arg.Timestamp)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetSyncOperationsSinceRow{}
	for rows.Next() {
		var i GetSyncOperationsSinceRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.OperationType,
			&i.EntityType,
			&i.EntityID,
			&i.OperationData,
			&i.DeviceFingerprint,
			&i.Timestamp,
			&i.DeviceName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateDeviceSessionLastSync = `-- name: UpdateDeviceSessionLastSync :exec
UPDATE device_sessions
SET last_sync_at = NOW()
WHERE user_id = $1 AND device_fingerprint = $2
`

type UpdateDeviceSessionLastSyncParams struct {
	UserID            pgtype.UUID `json:"user_id"`
	DeviceFingerprint string      `json:"device_fingerprint"`
}

func (q *Queries) UpdateDeviceSessionLastSync(ctx context.Context, arg UpdateDeviceSessionLastSyncParams) error {
	_, err := q.db.Exec(ctx, updateDeviceSessionLastSync, arg.UserID, arg.DeviceFingerprint)
	return err
}
