// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: otps.sql

package generated

import (
	"context"
)

const addOTP = `-- name: AddOTP :one
INSERT INTO otps (
  user_id,
  issuer,
  label,
  secret,
  algorithm,
  digits,
  period,
  counter,
  method,
  active
) VALUES (
  $1, $2, $3, $4, $5, $6, $7, $8, $9, $10
) RETURNING id, user_id, issuer, label, secret, algorithm, digits, period, counter, method, active, created_at
`

type AddOTPParams struct {
	UserID    int32  `json:"user_id"`
	Issuer    string `json:"issuer"`
	Label     string `json:"label"`
	Secret    string `json:"secret"`
	Algorithm string `json:"algorithm"`
	Digits    int32  `json:"digits"`
	Period    int32  `json:"period"`
	Counter   int32  `json:"counter"`
	Method    string `json:"method"`
	Active    bool   `json:"active"`
}

func (q *Queries) AddOTP(ctx context.Context, arg AddOTPParams) (Otp, error) {
	row := q.db.QueryRow(ctx, addOTP,
		arg.UserID,
		arg.Issuer,
		arg.Label,
		arg.Secret,
		arg.Algorithm,
		arg.Digits,
		arg.Period,
		arg.Counter,
		arg.Method,
		arg.Active,
	)
	var i Otp
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Issuer,
		&i.Label,
		&i.Secret,
		&i.Algorithm,
		&i.Digits,
		&i.Period,
		&i.Counter,
		&i.Method,
		&i.Active,
		&i.CreatedAt,
	)
	return i, err
}

const editOTP = `-- name: EditOTP :one
UPDATE otps
SET 
  issuer = $3,
  label = $4,
  secret = $5,
  algorithm = $6,
  digits = $7,
  period = $8,
  counter = $9,
  method = $10
WHERE id = $1 AND user_id = $2
RETURNING id, user_id, issuer, label, secret, algorithm, digits, period, counter, method, active, created_at
`

type EditOTPParams struct {
	ID        int32  `json:"id"`
	UserID    int32  `json:"user_id"`
	Issuer    string `json:"issuer"`
	Label     string `json:"label"`
	Secret    string `json:"secret"`
	Algorithm string `json:"algorithm"`
	Digits    int32  `json:"digits"`
	Period    int32  `json:"period"`
	Counter   int32  `json:"counter"`
	Method    string `json:"method"`
}

func (q *Queries) EditOTP(ctx context.Context, arg EditOTPParams) (Otp, error) {
	row := q.db.QueryRow(ctx, editOTP,
		arg.ID,
		arg.UserID,
		arg.Issuer,
		arg.Label,
		arg.Secret,
		arg.Algorithm,
		arg.Digits,
		arg.Period,
		arg.Counter,
		arg.Method,
	)
	var i Otp
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Issuer,
		&i.Label,
		&i.Secret,
		&i.Algorithm,
		&i.Digits,
		&i.Period,
		&i.Counter,
		&i.Method,
		&i.Active,
		&i.CreatedAt,
	)
	return i, err
}

const getOTP = `-- name: GetOTP :one
SELECT id, user_id, issuer, label, secret, algorithm, digits, period, counter, method, active, created_at FROM otps WHERE id = $1 AND user_id = $2 LIMIT 1
`

type GetOTPParams struct {
	ID     int32 `json:"id"`
	UserID int32 `json:"user_id"`
}

func (q *Queries) GetOTP(ctx context.Context, arg GetOTPParams) (Otp, error) {
	row := q.db.QueryRow(ctx, getOTP, arg.ID, arg.UserID)
	var i Otp
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Issuer,
		&i.Label,
		&i.Secret,
		&i.Algorithm,
		&i.Digits,
		&i.Period,
		&i.Counter,
		&i.Method,
		&i.Active,
		&i.CreatedAt,
	)
	return i, err
}

const inactivateOTP = `-- name: InactivateOTP :one
UPDATE otps
SET active = false
WHERE id = $1 AND user_id = $2
RETURNING id, user_id, issuer, label, secret, algorithm, digits, period, counter, method, active, created_at
`

type InactivateOTPParams struct {
	ID     int32 `json:"id"`
	UserID int32 `json:"user_id"`
}

func (q *Queries) InactivateOTP(ctx context.Context, arg InactivateOTPParams) (Otp, error) {
	row := q.db.QueryRow(ctx, inactivateOTP, arg.ID, arg.UserID)
	var i Otp
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Issuer,
		&i.Label,
		&i.Secret,
		&i.Algorithm,
		&i.Digits,
		&i.Period,
		&i.Counter,
		&i.Method,
		&i.Active,
		&i.CreatedAt,
	)
	return i, err
}

const listOTPs = `-- name: ListOTPs :many
SELECT id, user_id, issuer, label, secret, algorithm, digits, period, counter, method, active, created_at FROM otps WHERE user_id = $1 AND active = true
`

func (q *Queries) ListOTPs(ctx context.Context, userID int32) ([]Otp, error) {
	rows, err := q.db.Query(ctx, listOTPs, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Otp{}
	for rows.Next() {
		var i Otp
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Issuer,
			&i.Label,
			&i.Secret,
			&i.Algorithm,
			&i.Digits,
			&i.Period,
			&i.Counter,
			&i.Method,
			&i.Active,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
