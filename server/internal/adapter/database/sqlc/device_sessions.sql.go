// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: device_sessions.sql

package db

import (
	"context"
	"net/netip"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const cleanupExpiredDeviceSessions = `-- name: CleanupExpiredDeviceSessions :exec
UPDATE device_sessions
SET is_active = FALSE
WHERE expires_at <= NOW()
`

func (q *Queries) CleanupExpiredDeviceSessions(ctx context.Context) error {
	_, err := q.db.Exec(ctx, cleanupExpiredDeviceSessions)
	return err
}

const createDeviceSession = `-- name: CreateDeviceSession :one
INSERT INTO device_sessions (
    user_id, device_id, device_name, device_type,
    user_agent, ip_address, expires_at
)
VALUES ($1, $2, $3, $4, $5, $6, $7)
ON CONFLICT (user_id, device_id)
DO UPDATE SET
    device_name = EXCLUDED.device_name,
    device_type = EXCLUDED.device_type,
    user_agent = EXCLUDED.user_agent,
    ip_address = EXCLUDED.ip_address,
    last_sync_at = NOW(),
    expires_at = EXCLUDED.expires_at,
    is_active = TRUE
RETURNING id, user_id, device_id, device_name, device_type, user_agent, ip_address, last_sync_at, created_at, expires_at, is_active
`

type CreateDeviceSessionParams struct {
	UserID     pgtype.UUID `json:"user_id"`
	DeviceID   string      `json:"device_id"`
	DeviceName string      `json:"device_name"`
	DeviceType string      `json:"device_type"`
	UserAgent  pgtype.Text `json:"user_agent"`
	IpAddress  *netip.Addr `json:"ip_address"`
	ExpiresAt  time.Time   `json:"expires_at"`
}

func (q *Queries) CreateDeviceSession(ctx context.Context, arg CreateDeviceSessionParams) (DeviceSession, error) {
	row := q.db.QueryRow(ctx, createDeviceSession,
		arg.UserID,
		arg.DeviceID,
		arg.DeviceName,
		arg.DeviceType,
		arg.UserAgent,
		arg.IpAddress,
		arg.ExpiresAt,
	)
	var i DeviceSession
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.DeviceID,
		&i.DeviceName,
		&i.DeviceType,
		&i.UserAgent,
		&i.IpAddress,
		&i.LastSyncAt,
		&i.CreatedAt,
		&i.ExpiresAt,
		&i.IsActive,
	)
	return i, err
}

const createSyncOperation = `-- name: CreateSyncOperation :one
INSERT INTO sync_operations (
    user_id, device_session_id, operation_type,
    resource_type, resource_id, timestamp_vector
)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, user_id, device_session_id, operation_type, resource_type, resource_id, timestamp_vector, created_at
`

type CreateSyncOperationParams struct {
	UserID          pgtype.UUID `json:"user_id"`
	DeviceSessionID pgtype.UUID `json:"device_session_id"`
	OperationType   string      `json:"operation_type"`
	ResourceType    string      `json:"resource_type"`
	ResourceID      pgtype.UUID `json:"resource_id"`
	TimestampVector int64       `json:"timestamp_vector"`
}

func (q *Queries) CreateSyncOperation(ctx context.Context, arg CreateSyncOperationParams) (SyncOperation, error) {
	row := q.db.QueryRow(ctx, createSyncOperation,
		arg.UserID,
		arg.DeviceSessionID,
		arg.OperationType,
		arg.ResourceType,
		arg.ResourceID,
		arg.TimestampVector,
	)
	var i SyncOperation
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.DeviceSessionID,
		&i.OperationType,
		&i.ResourceType,
		&i.ResourceID,
		&i.TimestampVector,
		&i.CreatedAt,
	)
	return i, err
}

const deactivateDeviceSession = `-- name: DeactivateDeviceSession :exec
UPDATE device_sessions
SET is_active = FALSE
WHERE user_id = $1 AND device_id = $2
`

type DeactivateDeviceSessionParams struct {
	UserID   pgtype.UUID `json:"user_id"`
	DeviceID string      `json:"device_id"`
}

func (q *Queries) DeactivateDeviceSession(ctx context.Context, arg DeactivateDeviceSessionParams) error {
	_, err := q.db.Exec(ctx, deactivateDeviceSession, arg.UserID, arg.DeviceID)
	return err
}

const getActiveDeviceSessionsByUserID = `-- name: GetActiveDeviceSessionsByUserID :many
SELECT id, user_id, device_id, device_name, device_type, user_agent, ip_address, last_sync_at, created_at, expires_at, is_active FROM device_sessions
WHERE user_id = $1 AND is_active = TRUE AND expires_at > NOW()
ORDER BY last_sync_at DESC
`

func (q *Queries) GetActiveDeviceSessionsByUserID(ctx context.Context, userID pgtype.UUID) ([]DeviceSession, error) {
	rows, err := q.db.Query(ctx, getActiveDeviceSessionsByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []DeviceSession{}
	for rows.Next() {
		var i DeviceSession
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.DeviceID,
			&i.DeviceName,
			&i.DeviceType,
			&i.UserAgent,
			&i.IpAddress,
			&i.LastSyncAt,
			&i.CreatedAt,
			&i.ExpiresAt,
			&i.IsActive,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDeviceSession = `-- name: GetDeviceSession :one
SELECT id, user_id, device_id, device_name, device_type, user_agent, ip_address, last_sync_at, created_at, expires_at, is_active FROM device_sessions
WHERE user_id = $1 AND device_id = $2 AND is_active = TRUE
`

type GetDeviceSessionParams struct {
	UserID   pgtype.UUID `json:"user_id"`
	DeviceID string      `json:"device_id"`
}

func (q *Queries) GetDeviceSession(ctx context.Context, arg GetDeviceSessionParams) (DeviceSession, error) {
	row := q.db.QueryRow(ctx, getDeviceSession, arg.UserID, arg.DeviceID)
	var i DeviceSession
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.DeviceID,
		&i.DeviceName,
		&i.DeviceType,
		&i.UserAgent,
		&i.IpAddress,
		&i.LastSyncAt,
		&i.CreatedAt,
		&i.ExpiresAt,
		&i.IsActive,
	)
	return i, err
}

const getLatestSyncTimestamp = `-- name: GetLatestSyncTimestamp :one
SELECT COALESCE(MAX(timestamp_vector), 0) as latest_timestamp
FROM sync_operations
WHERE user_id = $1
`

func (q *Queries) GetLatestSyncTimestamp(ctx context.Context, userID pgtype.UUID) (interface{}, error) {
	row := q.db.QueryRow(ctx, getLatestSyncTimestamp, userID)
	var latest_timestamp interface{}
	err := row.Scan(&latest_timestamp)
	return latest_timestamp, err
}

const getSyncOperationsSince = `-- name: GetSyncOperationsSince :many
SELECT so.id, so.user_id, so.device_session_id, so.operation_type, so.resource_type, so.resource_id, so.timestamp_vector, so.created_at, ds.device_id, ds.device_name
FROM sync_operations so
LEFT JOIN device_sessions ds ON so.device_session_id = ds.id
WHERE so.user_id = $1 AND so.timestamp_vector > $2
ORDER BY so.timestamp_vector ASC
`

type GetSyncOperationsSinceParams struct {
	UserID          pgtype.UUID `json:"user_id"`
	TimestampVector int64       `json:"timestamp_vector"`
}

type GetSyncOperationsSinceRow struct {
	ID              pgtype.UUID        `json:"id"`
	UserID          pgtype.UUID        `json:"user_id"`
	DeviceSessionID pgtype.UUID        `json:"device_session_id"`
	OperationType   string             `json:"operation_type"`
	ResourceType    string             `json:"resource_type"`
	ResourceID      pgtype.UUID        `json:"resource_id"`
	TimestampVector int64              `json:"timestamp_vector"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
	DeviceID        pgtype.Text        `json:"device_id"`
	DeviceName      pgtype.Text        `json:"device_name"`
}

func (q *Queries) GetSyncOperationsSince(ctx context.Context, arg GetSyncOperationsSinceParams) ([]GetSyncOperationsSinceRow, error) {
	rows, err := q.db.Query(ctx, getSyncOperationsSince, arg.UserID, arg.TimestampVector)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetSyncOperationsSinceRow{}
	for rows.Next() {
		var i GetSyncOperationsSinceRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.DeviceSessionID,
			&i.OperationType,
			&i.ResourceType,
			&i.ResourceID,
			&i.TimestampVector,
			&i.CreatedAt,
			&i.DeviceID,
			&i.DeviceName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateDeviceSessionLastSync = `-- name: UpdateDeviceSessionLastSync :exec
UPDATE device_sessions
SET last_sync_at = NOW()
WHERE user_id = $1 AND device_id = $2
`

type UpdateDeviceSessionLastSyncParams struct {
	UserID   pgtype.UUID `json:"user_id"`
	DeviceID string      `json:"device_id"`
}

func (q *Queries) UpdateDeviceSessionLastSync(ctx context.Context, arg UpdateDeviceSessionLastSyncParams) error {
	_, err := q.db.Exec(ctx, updateDeviceSessionLastSync, arg.UserID, arg.DeviceID)
	return err
}
